<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>コトバト広場</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg-body: #0d1117; --bg-sidebar: #161b22; --bg-card: #21262d; --bg-input: #30363d;
            --primary: #58a6ff; --primary-dim: rgba(88, 166, 255, 0.15);
            --success: #238636; --danger: #da3633; --warning: #d29922;
            --text-main: #c9d1d9; --text-sub: #8b949e; --border: #30363d;
            --radius: 12px; --nav-h-mobile: 60px; --sidebar-w: 240px;
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }
        body { background: var(--bg-body); color: var(--text-main); font-family: 'Inter', 'Noto Sans JP', sans-serif; margin: 0; padding: 0; height: 100vh; overflow: hidden; display: flex; flex-direction: column; }
        
        /* Utility */
        .hidden { display: none !important; }
        .flex { display: flex; } .flex-col { flex-direction: column; } .items-center { align-items: center; } .justify-between { justify-content: space-between; }
        .gap-2 { gap: 8px; } .gap-4 { gap: 16px; }
        .font-bold { font-weight: 700; } .text-sm { font-size: 0.85rem; } .text-xs { font-size: 0.75rem; }
        .mb-2 { margin-bottom: 8px; } .mb-4 { margin-bottom: 16px; } .w-full { width: 100%; } .text-sub { color: var(--text-sub); }
        
        /* Icons */
        .icon { width: 20px; height: 20px; fill: currentColor; flex-shrink: 0; display: inline-block; vertical-align: middle; }
        .icon-lg { width: 24px; height: 24px; }
        .icon-xl { width: 48px; height: 48px; }
        
        /* Screens */
        .screen { position: absolute; inset: 0; background: var(--bg-body); z-index: 10; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; display: flex; flex-direction: column; }
        .screen.active { opacity: 1; pointer-events: auto; z-index: 20; }
        
        #splash-screen { position: fixed; inset: 0; background: var(--bg-body); z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 0.5s ease, visibility 0.5s; }
        #splash-screen.fade-out { opacity: 0; visibility: hidden; }
        .splash-logo { font-size: 3rem; font-weight: 900; background: linear-gradient(135deg, #58a6ff, #bc8cff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 20px; letter-spacing: 2px; }
        .loader { width: 40px; height: 40px; border: 4px solid var(--bg-input); border-top: 4px solid var(--primary); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Auth */
        .auth-container { flex: 1; display: flex; align-items: center; justify-content: center; background: radial-gradient(circle at center, #1f2937 0%, #0b0f19 100%); padding: 20px; }
        .auth-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 24px; padding: 40px 30px; width: 100%; max-width: 380px; text-align: center; box-shadow: 0 25px 50px rgba(0,0,0,0.5); }
        .brand-title { font-size: 2rem; font-weight: 900; background: linear-gradient(135deg, #58a6ff, #bc8cff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 2rem; letter-spacing: 1px; }
        
        /* Form Elements */
        .input-group { position: relative; width: 100%; }
        .input { width: 100%; padding: 12px; background: var(--bg-input); border: 1px solid var(--border); border-radius: 8px; color: #fff; font-size: 1rem; transition: border-color 0.2s; touch-action: manipulation; }
        .input:focus { border-color: var(--primary); }
        .pass-toggle { position: absolute; right: 12px; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--text-sub); cursor: pointer; padding: 0; display:flex; align-items:center; }
        
        /* Layout */
        .app-layout { display: flex; width: 100%; height: 100%; overflow: hidden; }
        .sidebar { width: var(--sidebar-w); background: var(--bg-sidebar); border-right: 1px solid var(--border); display: none; flex-direction: column; padding: 20px; flex-shrink: 0; }
        .sidebar-brand { font-size: 1.2rem; font-weight: 800; color: var(--text-main); margin-bottom: 30px; padding-left: 10px; cursor: pointer; }
        .nav-link { display: flex; align-items: center; gap: 12px; padding: 12px 16px; color: var(--text-sub); border-radius: 8px; cursor: pointer; margin-bottom: 4px; font-weight: 600; font-size: 0.95rem; }
        .nav-link.active { background: var(--primary-dim); color: var(--primary); }
        
        .main-content { flex: 1; display: flex; flex-direction: column; height: 100%; position: relative; overflow: hidden; background: var(--bg-body); }
        .header-mobile { height: 56px; background: var(--bg-sidebar); border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: center; padding: 0 16px; flex-shrink: 0; font-weight: 700; font-size: 1.1rem; position: relative; }
        .header-user { position: absolute; right: 16px; font-size: 0.8rem; color: var(--text-sub); }
        .scroll-view { flex: 1; min-height:0; overflow-y: auto; padding: 20px; padding-bottom: 80px; -webkit-overflow-scrolling: touch; overscroll-behavior: contain; touch-action: pan-y; }
        
        #scr-stamp-maker { height: 100vh; }
        #scr-stamp-maker .scroll-view { height: calc(100vh - 50px); flex: none; }

        .bottom-nav { height: var(--nav-h-mobile); background: var(--bg-sidebar); border-top: 1px solid var(--border); display: flex; align-items: center; justify-content: space-around; position: absolute; bottom: 0; left: 0; right: 0; z-index: 50; padding-bottom: env(safe-area-inset-bottom); transition: transform 0.3s; }
        .b-nav-item { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-sub); font-size: 0.65rem; gap: 4px; cursor: pointer; }
        .b-nav-item.active { color: var(--primary); }

        body.chat-mode .bottom-nav { transform: translateY(100%); }
        body.chat-mode .sidebar { display: none !important; }
        body.chat-mode .scroll-view { padding-bottom: 0 !important; }

        .card { background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius); padding: 20px; margin-bottom: 16px; position: relative; }
        .btn { width: 100%; padding: 12px; border-radius: 8px; border: none; font-weight: 700; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; font-size: 0.95rem; color: white; transition: 0.2s; }
        .btn:active { opacity: 0.7; transform: scale(0.98); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background: var(--success); } .btn-ghost { background: transparent; border: 1px solid var(--border); color: var(--text-sub); }
        .btn-danger { background: rgba(218, 54, 51, 0.15); color: var(--danger); border: 1px solid var(--danger); }
        .btn-warning { background: var(--warning); color: #000; } .btn-sm { padding: 6px 12px; font-size: 0.8rem; width: auto; }
        
        .res-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px; }
        .res-box { background: var(--bg-input); padding: 10px; border-radius: 10px; text-align: center; border: 1px solid var(--border); }
        .res-label { font-size: 0.65rem; color: var(--text-sub); display: block; font-weight: 700; }
        .res-val { font-size: 1.1rem; font-weight: 800; }

        /* Badges */
        .badge { display: inline-flex; align-items: center; padding: 2px 6px; border-radius: 4px; font-size: 0.6rem; margin-left: 6px; font-weight: bold; border: 1px solid currentColor; }
        .badge-developer { color: #fff; background: linear-gradient(135deg, #ff4b4b, #9b0000); border: none; }
        .badge-staff { color: #fff; background: linear-gradient(135deg, #d29922, #b87c00); border: none; }
        .badge-bug { color: #fff; background: linear-gradient(135deg, #238636, #165c26); border: none; }
        .badge-vip { color: #fff; background: linear-gradient(135deg, #a371f7, #6e40c9); border: none; }
        .badge-veteran { color: #fff; background: linear-gradient(135deg, #58a6ff, #1f6feb); border: none; }
        .badge-official { color: #fff; background: linear-gradient(135deg, #58a6ff, #0056b3); border: none; box-shadow: 0 0 5px rgba(88,166,255,0.5); }
        .badge-level { color: #58a6ff; border: 1px solid #58a6ff; }
        .badge-rich { color: #d29922; border: 1px solid #d29922; }
        .badge-whale { color: #bc8cff; border: 1px solid #bc8cff; }

        /* Chat & DM */
        .chat-header { height: 50px; background: var(--bg-sidebar); display: flex; align-items: center; padding: 0 16px; border-bottom: 1px solid var(--border); font-weight: bold; justify-content: space-between; flex-shrink: 0; }
        .chat-list { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 16px; }
        .chat-input-wrapper { background: var(--bg-sidebar); border-top: 1px solid var(--border); padding-bottom: calc(10px + env(safe-area-inset-bottom)); flex-shrink: 0; }
        
        #chat-reply-preview, #dm-reply-preview { display: none; padding: 8px 15px 0; align-items: center; gap: 10px; background: var(--bg-card); border-bottom: 1px solid var(--border); border-top: 1px solid var(--border); }
        .reply-thumb { height: 40px; border-radius: 4px; object-fit: cover; }
        .reply-text-preview { font-size: 0.8rem; color: var(--text-main); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; }
        .reply-name-preview { font-size: 0.7rem; color: var(--text-sub); margin-bottom: 2px; }
        .reply-box-in-msg { font-size: 0.75rem; color: var(--text-sub); background: rgba(255,255,255,0.05); padding: 6px 8px; border-radius: 6px; margin-bottom: 6px; border-left: 3px solid var(--primary); display: flex; align-items: center; gap: 6px; cursor: pointer; }
        .reply-box-in-msg img { height: 24px; border-radius: 4px; object-fit: cover; }

        .chat-input-area { padding: 10px 15px; display: flex; gap: 10px; align-items: center; }
        .chat-switcher { display: flex; justify-content: center; gap: 10px; flex: 1; }
        .chat-sw-btn { padding: 6px 12px; border-radius: 20px; font-size: 0.8rem; color: var(--text-sub); cursor: pointer; transition: 0.2s; }
        .chat-sw-btn.active { background: var(--primary-dim); color: var(--primary); font-weight: bold; }

        .msg-row { display: flex; flex-direction: column; max-width: 85%; position: relative; }
        .msg-row.mine { align-self: flex-end; align-items: flex-end; }
        .msg-row.other { align-self: flex-start; align-items: flex-start; }
        .msg-name { font-size: 0.7rem; color: var(--text-sub); margin-bottom: 4px; padding: 0 4px; cursor: pointer; }
        .msg-bubble { padding: 10px 14px; border-radius: 16px; font-size: 0.95rem; line-height: 1.5; word-break: break-word; position: relative; cursor: pointer; user-select: none; transition: opacity 0.2s; }
        .msg-bubble:active { opacity: 0.8; }
        .msg-row.mine .msg-bubble { background: #1f6feb; color: white; border-bottom-right-radius: 4px; }
        .msg-row.other .msg-bubble { background: var(--bg-card); border: 1px solid var(--border); border-bottom-left-radius: 4px; }
        .chat-img { max-width: 100%; border-radius: 8px; margin-top: 6px; display: block; cursor: zoom-in; }
        .stamp-img { width: 140px; height: 140px; object-fit: contain; display: block; cursor: default; }
        
        .dm-item { display: flex; align-items: center; gap: 12px; padding: 15px; border-bottom: 1px solid var(--border); cursor: pointer; transition: background 0.2s; }
        .dm-item:hover { background: var(--bg-input); }
        .dm-icon { width: 40px; height: 40px; background: var(--primary-dim); color: var(--primary); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 1.2rem; }

        /* Modals & Overlays */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 1000; display: none; align-items: center; justify-content: center; padding: 20px; backdrop-filter: blur(4px); }
        .modal-box { background: var(--bg-card); width: 100%; max-width: 500px; border-radius: 16px; border: 1px solid var(--border); overflow: hidden; max-height: 80vh; display: flex; flex-direction: column; }
        .modal-head { padding: 15px 20px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; font-weight: bold; }
        .modal-body { padding: 20px; overflow-y: auto; }
        
        .bottom-sheet { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 2000; display: none; flex-direction: column; justify-content: flex-end; }
        .bottom-sheet-content { background: var(--bg-card); border-top-left-radius: 16px; border-top-right-radius: 16px; padding: 20px; padding-bottom: calc(20px + env(safe-area-inset-bottom)); transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.1, 0.8, 0.3, 1); }
        .bottom-sheet.show { display: flex; }
        .bottom-sheet.show .bottom-sheet-content { transform: translateY(0); }
        .sheet-btn { width: 100%; padding: 16px; text-align: left; background: transparent; border: none; border-bottom: 1px solid var(--border); color: var(--text-main); font-size: 1rem; cursor: pointer; display: flex; align-items: center; gap: 12px; }
        .sheet-btn.danger { color: var(--danger); }
        
        .toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: var(--primary); color: #fff; padding: 10px 24px; border-radius: 50px; font-weight: 700; z-index: 2000; opacity: 0; transition: 0.3s; pointer-events: none; }
        .toast.show { opacity: 1; }

        /* Stamp Grid */
        .stamp-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; padding: 10px 0; }
        .stamp-item { aspect-ratio: 1; background: var(--bg-input); border-radius: 8px; display: flex; align-items: center; justify-content: center; cursor: pointer; border: 1px solid transparent; position: relative; }
        .stamp-item:hover { border-color: var(--primary); }
        .stamp-item img { width: 100%; height: 100%; object-fit: contain; padding: 4px; }
        .stamp-tabs { display: flex; border-bottom: 1px solid var(--border); margin-bottom: 10px; }
        .stamp-tab { flex: 1; text-align: center; padding: 10px; cursor: pointer; color: var(--text-sub); border-bottom: 2px solid transparent; }
        .stamp-tab.active { color: var(--primary); border-bottom-color: var(--primary); font-weight: bold; }

        /* Maker Canvas */
        .mk-toolbar { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
        .mk-toolbtn { padding:8px 10px; border-radius:10px; border:1px solid var(--border); background:rgba(255,255,255,0.03); color:var(--text-main); font-weight:700; font-size:0.8rem; cursor:pointer; }
        .mk-toolbtn.active { border-color: var(--primary); background: var(--primary-dim); color: var(--primary); }
        .mk-canvas-wrap { position:relative; width:100%; aspect-ratio: 1; border-radius: 14px; border:1px solid var(--border); background: conic-gradient(from 90deg, rgba(255,255,255,0.08) 0 25%, rgba(255,255,255,0.02) 0 50%, rgba(255,255,255,0.08) 0 75%, rgba(255,255,255,0.02) 0 100%); background-size: 24px 24px; overflow:hidden; }
        #mk-canvas { width:100%; height:100%; display:block; }
        .mk-pill { display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px; background:rgba(255,255,255,0.05); border:1px solid var(--border); font-size:0.75rem; }
        .mk-warn { color: #ffcc66; } .mk-err { color: #ff7b72; }
        .pk-grid { display:grid; grid-template-columns: repeat(4, 1fr); gap: 12px; }
        .pk-slot { background: rgba(255,255,255,0.03); border: 1px solid var(--border); border-radius: 14px; padding: 10px; position: relative; overflow:hidden; }
        .pk-thumb { width: 100%; aspect-ratio: 1; border-radius: 12px; background: conic-gradient(from 90deg, rgba(255,255,255,0.08) 0 25%, rgba(255,255,255,0.02) 0 50%, rgba(255,255,255,0.08) 0 75%, rgba(255,255,255,0.02) 0 100%); background-size: 18px 18px; display:flex; align-items:center; justify-content:center; border:1px solid rgba(255,255,255,0.06); }
        .pk-thumb img { width: 100%; height: 100%; object-fit: contain; padding: 6px; }

        /* Call Screen */
        #scr-call { background: #000; z-index: 50; overflow: hidden; }
        .video-container { position: absolute; inset: 0; z-index: 0; display: flex; align-items: center; justify-content: center; background: #000; }
        #remote-video { width: 100%; height: 100%; object-fit: contain; }
        #local-video { position: absolute; bottom: 120px; right: 20px; width: 100px; height: 150px; object-fit: cover; border-radius: 12px; border: 2px solid var(--primary); background: #333; z-index: 10; transition: all 0.3s; display: none; }
        #local-video.active { display: block; }
        #call-overlay { position: absolute; inset: 0; z-index: 5; display: flex; flex-direction: column; justify-content: space-between; padding: 40px 20px; pointer-events: none; background: linear-gradient(to bottom, rgba(0,0,0,0.5) 0%, transparent 20%, transparent 80%, rgba(0,0,0,0.8) 100%); }
        .call-info { text-align: center; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
        .call-avatar { width: 100px; height: 100px; border-radius: 50%; background: #333; display: flex; align-items: center; justify-content: center; font-size: 3rem; margin: 0 auto 20px; border: 2px solid var(--text-main); }
        .call-controls { display: flex; justify-content: center; gap: 15px; pointer-events: auto; padding-bottom: 20px; }
        .call-btn { width: 60px; height: 60px; border-radius: 50%; border: none; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; cursor: pointer; color: white; background: rgba(255,255,255,0.2); backdrop-filter: blur(5px); }

        @media (min-width: 768px) {
            .sidebar { display: flex; } .bottom-nav { display: none; } .header-mobile { display: none; } .scroll-view { padding-bottom: 20px; }
            .pk-grid { grid-template-columns: repeat(6, 1fr); }
            .bottom-sheet { align-items: center; justify-content: center; }
            .bottom-sheet-content { border-radius: 16px; width: 100%; max-width: 400px; padding-bottom: 20px; transform: scale(0.95); opacity: 0; }
            .bottom-sheet.show .bottom-sheet-content { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body>

    <div id="splash-screen">
        <div class="splash-logo">COTOBATO</div>
        <div class="loader"></div>
    </div>

    <div id="toast" class="toast">メッセージ</div>
    <div id="img-viewer" class="modal-overlay" onclick="this.style.display='none'"><img id="img-full" style="max-width:100%; max-height:100vh; object-fit:contain;"></div>

    <!-- Call Screen -->
    <div id="scr-call" class="screen">
        <div class="video-container">
            <video id="remote-video" autoplay playsinline></video>
            <video id="local-video" autoplay playsinline muted></video>
        </div>
        <div id="call-overlay">
            <div id="call-ui-calling" class="flex flex-col items-center justify-between h-full py-10 hidden">
                <div class="call-info" style="margin-top:40px">
                    <div id="call-avatar" class="call-avatar"><svg class="icon icon-xl" viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg></div>
                    <div id="call-status-text" class="text-xl font-bold mb-2">Calling...</div>
                    <div id="call-name" class="text-lg font-bold">User</div>
                </div>
                <button class="call-btn hangup" style="background:#da3633" onclick="app.endCall()"><svg class="icon icon-lg" viewBox="0 0 24 24"><path d="M12 9c-1.6 0-3.15.25-4.6.72-.81.26-1.38.94-1.38 1.81l-.01 3.07c0 .84.53 1.58 1.3 1.87 1.58.6 3.26.93 5.01.93 1.76 0 3.45-.33 5.03-.94.77-.29 1.28-1.03 1.28-1.87l-.01-3.07c0-.88-.58-1.56-1.4-1.81C15.58 9.25 14.03 9 12 9zm7.04 6.69c-1.11.41-2.29.69-3.52.83v-1.96c0-.52-.39-.96-.89-1.05-.72-.12-1.47-.19-2.23-.19s-1.51.07-2.23.19c-.5.09-.89.53-.89 1.05v1.96c-1.23-.14-2.41-.42-3.52-.83-.34-.13-.52-.51-.44-.86l.63-2.61c.1-.4.49-.66.89-.57 1.15.26 2.37.43 3.63.43 1.25 0 2.47-.17 3.63-.43.41-.09.79.17.89.57l.63 2.61c.08.35-.1.73-.44.86z"/></svg></button>
            </div>
            <div id="call-ui-incoming" class="flex flex-col items-center justify-between h-full py-10 hidden">
                <div class="call-info" style="margin-top:40px">
                    <div class="call-avatar"><svg class="icon icon-xl" viewBox="0 0 24 24"><path d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56-.35-.12-.74-.03-1.01.24l-2.2 2.2c-3.23-1.61-5.81-4.19-7.43-7.43l2.2-2.2c.27-.27.35-.66.24-1.01-.36-1.11-.56-2.3-.56-3.53 0-.54-.45-1-1-1H4.17c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-2.65c0-.54-.45-1-1-1z"/></svg></div>
                    <div class="text-xl font-bold mb-2">Incoming Call</div>
                    <div id="inc-call-name" class="text-lg font-bold">User</div>
                    <div id="inc-call-type" class="text-sm text-sub">Audio</div>
                </div>
                <div class="flex gap-4" style="margin-bottom:20px">
                    <button class="call-btn answer" style="background:#238636" onclick="app.answerCall()"><svg class="icon icon-lg" viewBox="0 0 24 24"><path d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56-.35-.12-.74-.03-1.01.24l-2.2 2.2c-3.23-1.61-5.81-4.19-7.43-7.43l2.2-2.2c.27-.27.35-.66.24-1.01-.36-1.11-.56-2.3-.56-3.53 0-.54-.45-1-1-1H4.17c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-2.65c0-.54-.45-1-1-1z"/></svg></button>
                    <button class="call-btn hangup" style="background:#da3633" onclick="app.endCall()"><svg class="icon icon-lg" viewBox="0 0 24 24"><path d="M12 9c-1.6 0-3.15.25-4.6.72-.81.26-1.38.94-1.38 1.81l-.01 3.07c0 .84.53 1.58 1.3 1.87 1.58.6 3.26.93 5.01.93 1.76 0 3.45-.33 5.03-.94.77-.29 1.28-1.03 1.28-1.87l-.01-3.07c0-.88-.58-1.56-1.4-1.81C15.58 9.25 14.03 9 12 9zm7.04 6.69c-1.11.41-2.29.69-3.52.83v-1.96c0-.52-.39-.96-.89-1.05-.72-.12-1.47-.19-2.23-.19s-1.51.07-2.23.19c-.5.09-.89.53-.89 1.05v1.96c-1.23-.14-2.41-.42-3.52-.83-.34-.13-.52-.51-.44-.86l.63-2.61c.1-.4.49-.66.89-.57 1.15.26 2.37.43 3.63.43 1.25 0 2.47-.17 3.63-.43.41-.09.79.17.89.57l.63 2.61c.08.35-.1.73-.44.86z"/></svg></button>
                </div>
            </div>
            <div id="call-ui-connected" class="flex flex-col justify-end h-full py-10 hidden">
                 <div class="call-controls" style="padding-bottom:20px">
                    <button id="btn-video-toggle" class="call-btn" onclick="app.toggleVideo()"><svg class="icon icon-lg" viewBox="0 0 24 24"><path d="M15 8v8H5V8h10m1-2H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4V7c0-.55-.45-1-1-1z"/></svg></button>
                    <button id="btn-mic-toggle" class="call-btn active" onclick="app.toggleMic()"><svg class="icon icon-lg" viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg></button>
                    <button class="call-btn hangup" style="background:#da3633" onclick="app.endCall()"><svg class="icon icon-lg" viewBox="0 0 24 24"><path d="M12 9c-1.6 0-3.15.25-4.6.72-.81.26-1.38.94-1.38 1.81l-.01 3.07c0 .84.53 1.58 1.3 1.87 1.58.6 3.26.93 5.01.93 1.76 0 3.45-.33 5.03-.94.77-.29 1.28-1.03 1.28-1.87l-.01-3.07c0-.88-.58-1.56-1.4-1.81C15.58 9.25 14.03 9 12 9zm7.04 6.69c-1.11.41-2.29.69-3.52.83v-1.96c0-.52-.39-.96-.89-1.05-.72-.12-1.47-.19-2.23-.19s-1.51.07-2.23.19c-.5.09-.89.53-.89 1.05v1.96c-1.23-.14-2.41-.42-3.52-.83-.34-.13-.52-.51-.44-.86l.63-2.61c.1-.4.49-.66.89-.57 1.15.26 2.37.43 3.63.43 1.25 0 2.47-.17 3.63-.43.41-.09.79.17.89.57l.63 2.61c.08.35-.1.73-.44.86z"/></svg></button>
                </div>
            </div>
        </div>
        <audio id="remote-audio" autoplay></audio>
    </div>

    <!-- スタンプ選択モーダル -->
    <div id="stamp-modal" class="modal-overlay" onclick="if(event.target===this) app.closeStampModal()">
        <div class="modal-box" style="height: 60vh;">
            <div class="modal-head">
                <span>スタンプ</span>
                <button class="btn btn-ghost" style="width:30px;padding:0" onclick="app.closeStampModal()"><svg class="icon" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg></button>
            </div>
            <div class="modal-body" style="padding:0; display:flex; flex-direction:column; height:100%;">
                <div class="stamp-tabs">
                    <div class="stamp-tab active" onclick="app.switchStampTab('public')" id="tab-stamp-public">みんなの</div>
                    <div class="stamp-tab" onclick="app.switchStampTab('private')" id="tab-stamp-private">マイスタンプ</div>
                </div>
                <div id="stamp-list" class="stamp-grid" style="overflow-y:auto; flex:1; padding:10px;"></div>
                <div class="p-3 border-t border-[var(--border)]">
                    <button class="btn btn-primary btn-sm" onclick="app.openStampMaker(); app.closeStampModal();">＋ 新規作成</button>
                </div>
            </div>
        </div>
    </div>

    <!-- スタンプ作成専用画面 -->
    <div id="scr-stamp-maker" class="screen" style="z-index: 50; background: var(--bg-body);">
        <div class="chat-header">
            <div onclick="app.closeStampMaker()" style="cursor:pointer; display:flex; align-items:center; gap:4px; color:var(--primary); font-size:0.9rem;">
                <svg class="icon" viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>戻る
            </div>
            <span>スタンプメーカー</span>
            <button class="btn btn-ghost btn-sm" style="width:auto" onclick="app.pkResetDraft()">下書きリセット</button>
        </div>

        <div class="scroll-view" style="display:flex; flex-direction:column; padding:20px; overflow-y:auto; min-height:0; -webkit-overflow-scrolling:touch;">
            <div id="pk-step-basic" style="display:block;">
                <div class="card" style="padding:0; overflow:hidden;">
                    <div style="padding:18px 18px 14px; background:linear-gradient(135deg, rgba(88,166,255,0.18), rgba(188,140,255,0.10)); border-bottom:1px solid var(--border);">
                        <div class="font-bold text-lg">1. 基本設定と販売設定</div>
                    </div>
                    <div style="padding:18px;">
                        <div class="mk-row mb-3" style="align-items:flex-start;">
                            <label>パック名</label>
                            <input type="text" id="pk-title" class="input" placeholder="例: あいさつセット (1〜24文字)" style="flex:1" oninput="app.pkRender()">
                        </div>
                        <div class="mk-row mb-3" style="align-items:flex-start;">
                            <label>メイン画像</label>
                            <div style="flex:1" class="p-3 border border-[var(--border)] rounded-xl bg-[rgba(255,255,255,0.02)] flex gap-3">
                                <div style="width:80px; height:80px; border-radius:10px; background:rgba(255,255,255,0.05); display:flex; align-items:center; justify-content:center; overflow:hidden;">
                                    <img id="pk-main-preview" src="" style="width:100%; height:100%; object-fit:contain; display:none">
                                </div>
                                <div class="flex-1">
                                    <div class="text-xs text-sub mb-2">パックの表紙（必須）</div>
                                    <button class="btn btn-ghost btn-sm" style="width:auto; margin-bottom:5px;" onclick="document.getElementById('pk-main-file').click()">画像を選択</button>
                                    <button class="btn btn-ghost btn-sm" style="width:auto" onclick="app.pkOpenEditor('main')">編集ツール</button>
                                    <input id="pk-main-file" type="file" accept="image/*" style="display:none" onchange="app.pkHandleMainFile(this)">
                                </div>
                            </div>
                        </div>
                        <div class="mk-row mb-3" style="align-items:flex-start;">
                            <label>公開設定</label>
                            <select id="pk-public" class="input" style="flex:1" onchange="app.pkRender()"><option value="true">みんなのスタンプ(公開)</option><option value="false">自分用(非公開)</option></select>
                        </div>
                        <div class="mk-row mb-3" style="align-items:flex-start;">
                            <label>販売設定</label>
                            <div style="flex:1" class="flex flex-col gap-2">
                                <select id="pk-price-type" class="input" onchange="const v=this.value==='paid'; document.getElementById('pk-price-val').classList.toggle('hidden',!v); document.getElementById('pk-price-hint').classList.toggle('hidden',!v); app.pkRender();">
                                    <option value="free">無料</option><option value="paid">有料（コイン）</option>
                                </select>
                                <input type="number" id="pk-price-val" class="input hidden" placeholder="価格 (100〜10000コイン)" min="100" max="10000" oninput="app.pkRender()">
                                <div class="text-xs text-warning hidden" id="pk-price-hint">※売上の70%が作成者に、30%がシステム手数料となります。</div>
                            </div>
                        </div>
                        <div class="mt-4"><button id="pk-btn-next" class="btn btn-ghost" onclick="app.pkGoToStep2()" disabled>次へ (スタンプ登録)</button></div>
                    </div>
                </div>
            </div>

            <div id="pk-step-stamps" style="display:none;">
                <div class="card" style="padding:0; overflow:hidden;">
                    <div style="padding:18px; background:linear-gradient(135deg, rgba(88,166,255,0.18), rgba(188,140,255,0.10)); border-bottom:1px solid var(--border); display:flex; justify-content:space-between; align-items:center;">
                        <div class="font-bold text-lg">2. スタンプ登録</div><button class="btn btn-ghost btn-sm" style="width:auto" onclick="app.pkGoToStep1()">戻る</button>
                    </div>
                    <div style="padding:18px;">
                        <div class="flex justify-between items-center mb-3">
                            <span class="text-sm">画像ファイル(複数可)を選択して登録</span>
                            <button class="btn btn-primary btn-sm" style="width:auto" onclick="document.getElementById('pk-bulk-file').click()">＋ まとめて追加</button>
                            <input id="pk-bulk-file" type="file" accept="image/*" multiple style="display:none" onchange="app.pkHandleBulkFiles(this)">
                        </div>
                        <div id="pk-grid" class="pk-grid"></div>
                        <div class="flex gap-2" style="margin-top:14px;"><button class="btn btn-ghost btn-sm" style="width:auto" onclick="app.pkAddEmptySlot(4)">＋ 枠を増やす</button></div>
                        <div class="mk-hint" style="margin-top:14px;"><div id="pk-validate" class="mk-pill">状態: 未作成</div></div>
                        <div class="flex gap-2 mt-4"><button class="btn btn-primary" onclick="app.pkSubmitPack()">申請する</button><button class="btn btn-ghost" onclick="app.pkSaveDraft()">下書き保存</button></div>
                    </div>
                </div>
            </div>

            <!-- Canvas Editor -->
            <div class="card" id="mk-editor-card" style="display:none; margin-top:20px;">
                <div class="flex items-center justify-between mb-2">
                    <h3>キャンバス編集</h3>
                    <div class="flex gap-2"><span class="text-xs text-sub" id="mk-edit-target">slot</span><button class="btn btn-ghost btn-sm" style="width:auto" onclick="app.pkCloseEditor()">閉じる</button></div>
                </div>
                <div class="mk-toolbar mb-3">
                    <button class="mk-toolbtn active" id="tool-move" onclick="app.mkSetTool('move')">移動</button>
                    <button class="mk-toolbtn" id="tool-pen" onclick="app.mkSetTool('pen')">ペン</button>
                    <button class="mk-toolbtn" id="tool-rect" onclick="app.mkSetTool('rect')">四角</button>
                    <button class="mk-toolbtn" id="tool-text" onclick="app.mkSetTool('text')">文字</button>
                    <button class="mk-toolbtn" onclick="app.mkUndo()">↶ 戻す</button>
                    <button class="mk-toolbtn" onclick="app.mkClear()">クリア</button>
                </div>
                <div class="mk-canvas-wrap" style="max-width:360px; margin: 0 auto 10px;">
                    <canvas id="mk-canvas" width="512" height="512"></canvas>
                </div>
                <div class="mk-row mb-2">
                    <label>線の太さ</label><input id="mk-stroke" type="range" min="1" max="40" value="8" style="flex:1" onchange="app.mkUpdateStyle()" oninput="app.mkUpdateStyle()"><span class="text-xs text-sub" id="mk-stroke-v">8</span>
                </div>
                <div class="mk-row mb-4">
                    <label>色</label><input id="mk-color" type="color" value="#ffffff" onchange="app.mkUpdateStyle()" oninput="app.mkUpdateStyle()">
                    <button class="mk-toolbtn" onclick="app.mkToggleEraser()" id="mk-eraser">消しゴム</button>
                    <button class="mk-toolbtn" onclick="app.mkSetBgTransparent()">背景透過</button>
                    <button class="mk-toolbtn" onclick="app.mkSetBgWhite()">背景白</button>
                </div>
                <div class="flex gap-2">
                    <button class="btn btn-primary" onclick="app.pkSaveEditedStamp()">保存して反映</button>
                    <button class="btn btn-ghost" onclick="app.pkSetAsMainFromCurrent()">この画像をメインに</button>
                </div>
            </div>
        </div>
    </div>

    <!-- メッセージ操作メニュー -->
    <div id="msg-action-sheet" class="bottom-sheet" onclick="if(event.target===this) app.closeMsgAction()">
        <div class="bottom-sheet-content">
            <div id="msg-action-target" class="text-xs text-sub mb-3" style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis; padding: 0 16px;"></div>
            <button class="sheet-btn" onclick="app.prepareReply()">返信する</button>
            <button id="btn-msg-del" class="sheet-btn danger hidden" onclick="app.execDelMsg()">削除する</button>
            <button class="sheet-btn" onclick="app.closeMsgAction()" style="justify-content:center; color:var(--text-sub); margin-top:10px; border-top:1px solid var(--border);">キャンセル</button>
        </div>
    </div>

    <!-- Login / Auth Screens -->
    <div id="scr-login" class="screen active">
        <div class="auth-container">
            <div class="auth-card">
                <div class="brand-title">COTOBATO</div>
                <input type="text" id="inp-uid" class="input mb-4" placeholder="ユーザーID (半角英数)">
                <div class="input-group mb-4">
                    <input type="password" id="inp-pass" class="input" placeholder="パスワード">
                    <button class="pass-toggle" onclick="app.togglePass('inp-pass', this)"><svg class="icon" viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg></button>
                </div>
                <button class="btn btn-primary mb-4" onclick="app.login()">ログイン</button>
                <div class="flex gap-2 justify-center">
                    <button class="btn btn-ghost btn-sm" onclick="app.go('scr-register')">新規登録</button>
                    <button class="btn btn-ghost btn-sm" onclick="app.go('scr-reset-pass')">パスワードを忘れた</button>
                </div>
            </div>
        </div>
    </div>

    <div id="scr-register" class="screen">
        <div class="auth-container">
            <div class="auth-card">
                <h2 class="mb-4">新規登録</h2>
                <input type="text" id="reg-uid" class="input mb-4" placeholder="希望ID">
                <input type="text" id="reg-name" class="input mb-4" placeholder="表示名 (チャットでの名前)">
                <div class="input-group mb-2">
                    <input type="password" id="reg-pass" class="input" placeholder="パスワード">
                    <button class="pass-toggle" onclick="app.togglePass('reg-pass', this)"><svg class="icon" viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg></button>
                </div>
                <div class="text-left text-xs text-sub mb-1">秘密の質問 (パスワードリセット用)</div>
                <select id="reg-q" class="input mb-2"><option value="pet">初めて飼ったペットの名前は？</option><option value="school">小学校の名前は？</option><option value="mother">母親の旧姓は？</option><option value="food">好きな食べ物は？</option></select>
                <input type="text" id="reg-a" class="input mb-4" placeholder="答え">
                <button class="btn btn-primary mb-4" onclick="app.register()">登録して開始</button>
                <button class="btn btn-ghost" onclick="app.go('scr-login')">キャンセル</button>
            </div>
        </div>
    </div>

    <div id="scr-reset-pass" class="screen">
        <div class="auth-container">
            <div class="auth-card">
                <h2 class="mb-4">パスワード再設定</h2>
                <div id="rst-step-1">
                    <input type="text" id="rst-uid" class="input mb-4" placeholder="ユーザーID">
                    <button class="btn btn-primary" onclick="app.checkSecurityQuestion()">次へ</button>
                </div>
                <div id="rst-step-2" class="hidden">
                    <div class="mb-2 text-sm text-sub">秘密の質問</div>
                    <div id="rst-q-text" class="font-bold mb-4"></div>
                    <input type="text" id="rst-ans" class="input mb-4" placeholder="答え">
                    <input type="password" id="rst-new-pass" class="input mb-4" placeholder="新しいパスワード">
                    <button class="btn btn-primary" onclick="app.doResetPass()">設定変更</button>
                </div>
                <button class="btn btn-ghost mt-4" onclick="app.go('scr-login')">戻る</button>
            </div>
        </div>
    </div>

    <!-- Main App -->
    <div id="scr-main" class="screen">
        <div class="app-layout">
            <nav class="sidebar">
                <div class="sidebar-brand" onclick="location.reload()">COTOBATO</div>
                <div class="nav-link active" onclick="app.tab('home')" data-tab="home"><svg class="icon" viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>ホーム</div>
                <div class="nav-link" onclick="app.tab('chat')" data-tab="chat"><svg class="icon" viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/></svg>チャット</div>
                <div class="nav-link" onclick="app.tab('trade')" data-tab="trade"><svg class="icon" viewBox="0 0 24 24"><path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zM1 2v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1H5.21l-.94-2H1zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2z"/></svg>取引所</div>
                <div class="nav-link" onclick="app.tab('stamps')" data-tab="stamps"><svg class="icon" viewBox="0 0 24 24"><path d="M22 2H2v20l4-4h16V2zM13 13h-2v-2h2v2zm0-4h-2V7h2v2z"/></svg>スタンプ</div>
                <div class="nav-link" onclick="app.tab('settings')" data-tab="settings"><svg class="icon" viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L3.16 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.04.64.09.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>設定</div>
                <div class="nav-link hidden" id="nav-adm-pc" style="color:var(--warning)" onclick="app.tab('admin')" data-tab="admin"><svg class="icon" viewBox="0 0 24 24"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 6c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3z"/></svg>運営管理</div>
            </nav>

            <div class="main-content">
                <header class="header-mobile"><span>Cotobato</span><span id="header-user-name" class="header-user">Guest</span></header>

                <div id="tab-home" class="scroll-view">
                    <div id="profile-badges-top" class="mb-2 text-center"></div>
                    <div class="res-grid">
                        <div class="res-box"><span class="res-label">LEVEL</span><span class="res-val" id="v-level">1</span></div>
                        <div class="res-box"><span class="res-label">COINS</span><span class="res-val" id="v-coin" style="color:var(--warning)">0</span></div>
                        <div class="res-box"><span class="res-label">GEMS</span><span class="res-val" id="v-gem" style="color:var(--primary)">0</span></div>
                    </div>
                    <div class="card flex items-center justify-between" style="border-color:var(--warning)">
                        <div><div class="font-bold text-sm" style="color:var(--warning)">プレゼントBOX</div><div class="text-xs text-sub">ログインボーナス等</div></div>
                        <button class="btn btn-sm btn-primary" style="background:var(--warning); color:#000; width:auto;" onclick="app.checkGifts()">確認</button>
                    </div>
                    <h3 class="font-bold mb-4 mt-4">お知らせ</h3>
                    <div id="news-list" class="flex-col flex"></div>
                </div>

                <div id="tab-chat" class="hidden" style="height:100%; flex-direction:column; background:var(--bg-body);">
                    <div class="chat-header">
                        <div onclick="app.tab('home')" style="cursor:pointer; display:flex; align-items:center; gap:4px; color:var(--primary); font-size:0.9rem; white-space:nowrap;">
                            <svg class="icon" viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>戻る
                        </div>
                        <div class="chat-switcher">
                            <span class="chat-sw-btn active" id="sw-all" onclick="app.switchChatMode('all')">全体チャット</span>
                            <span class="chat-sw-btn" id="sw-dm" onclick="app.switchChatMode('dm')">友達・DM</span>
                        </div>
                        <div style="width:50px;"></div>
                    </div>
                    
                    <div id="area-all-chat" style="display:flex; flex-direction:column; flex:1; overflow:hidden;">
                        <div id="chat-box" class="chat-list"></div>
                        <div class="chat-input-wrapper">
                            <div id="chat-reply-preview">
                                <div style="flex:1; overflow:hidden;"><div class="reply-name-preview" id="chat-rep-name"></div><div class="reply-text-preview" id="chat-rep-text"></div></div>
                                <img id="chat-rep-img" class="reply-thumb hidden"><button class="btn btn-ghost btn-sm" style="width:auto; padding:4px;" onclick="app.cancelReply('all')">✕</button>
                            </div>
                            <form class="chat-input-area" onsubmit="event.preventDefault(); app.sendChat();">
                                <label class="btn btn-ghost" style="width:40px; padding:0; cursor:pointer;" onclick="app.openStampModal()"><svg class="icon icon-lg" viewBox="0 0 24 24"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"/></svg></label>
                                <label class="btn btn-ghost" style="width:40px; padding:0; cursor:pointer;"><svg class="icon icon-lg" viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg><input type="file" id="chat-file" accept="image/*" style="display:none" onchange="app.handleFileSelect(this, 'chat')"></label>
                                <input type="text" id="chat-in" class="input" placeholder="メッセージ..." style="margin:0;">
                                <button type="submit" class="btn btn-primary" style="width:50px; padding:0;"><svg class="icon" viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg></button>
                            </form>
                            <div id="chat-preview"><img id="chat-preview-img" class="preview-thumb"><span class="text-xs text-sub">画像を送信します</span><button class="btn btn-ghost btn-sm" style="margin-left:auto;" onclick="app.clearChatImg()">取消</button></div>
                        </div>
                    </div>

                    <div id="area-dm-list" style="display:none; flex-direction:column; flex:1; overflow-y:auto; padding:10px;">
                        <div class="card" style="padding:15px; margin-bottom:15px; border-color:var(--primary);">
                            <div class="font-bold text-sm mb-2">友達追加</div>
                            <div class="text-xs text-sub mb-2">相手のIDを入力して検索してください。</div>
                            <div class="flex gap-2 mb-2">
                                <input type="text" id="inline-friend-id" class="input" placeholder="ID (例: user123)">
                                <button class="btn btn-primary" style="width:auto" onclick="app.searchUserForFriendInline()">検索</button>
                            </div>
                            <div id="inline-friend-result" class="text-center"></div>
                        </div>
                        <div class="card" style="padding:15px; margin-bottom:15px;">
                            <div class="font-bold text-sm mb-2" style="color:var(--warning)">届いている申請</div>
                            <div id="requests-list" class="mb-2"></div>
                            <hr style="border-color:var(--border); margin:10px 0;">
                            <div class="font-bold text-sm mb-2 text-sub">送った申請</div>
                            <div id="outgoing-list"></div>
                        </div>
                        <div class="font-bold text-sm mb-2 px-2">友達リスト</div>
                        <div id="dm-list-box"></div>
                    </div>
                </div>

                <div id="scr-dm-talk" class="screen" style="background:var(--bg-body); z-index:30;">
                    <div class="chat-header">
                        <div onclick="app.closeDM()" style="cursor:pointer; display:flex; align-items:center; gap:4px; color:var(--primary); font-size:0.9rem; white-space:nowrap;">
                            <svg class="icon" viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>戻る
                        </div>
                        <span id="dm-talk-name">相手の名前</span>
                        <div style="display:flex; align-items:center;">
                             <button class="btn btn-ghost" style="width:40px; padding:0; margin-right:5px; color:var(--success);" onclick="app.startCall(false)"><svg class="icon icon-lg" viewBox="0 0 24 24"><path d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56-.35-.12-.74-.03-1.01.24l-2.2 2.2c-3.23-1.61-5.81-4.19-7.43-7.43l2.2-2.2c.27-.27.35-.66.24-1.01-.36-1.11-.56-2.3-.56-3.53 0-.54-.45-1-1-1H4.17c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-2.65c0-.54-.45-1-1-1z"/></svg></button>
                             <button class="btn btn-ghost" style="width:40px; padding:0; margin-right:5px; color:var(--primary);" onclick="app.startCall(true)"><svg class="icon icon-lg" viewBox="0 0 24 24"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg></button>
                        </div>
                    </div>
                    <div id="dm-talk-box" class="chat-list"></div>
                    <div class="chat-input-wrapper">
                        <div id="dm-reply-preview">
                            <div style="flex:1; overflow:hidden;"><div class="reply-name-preview" id="dm-rep-name"></div><div class="reply-text-preview" id="dm-rep-text"></div></div>
                            <img id="dm-rep-img" class="reply-thumb hidden"><button class="btn btn-ghost btn-sm" style="width:auto; padding:4px;" onclick="app.cancelReply('dm')">✕</button>
                        </div>
                        <form class="chat-input-area" onsubmit="event.preventDefault(); app.sendDM();">
                            <label class="btn btn-ghost" style="width:40px; padding:0; cursor:pointer;" onclick="app.openStampModal()"><svg class="icon icon-lg" viewBox="0 0 24 24"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"/></svg></label>
                            <label class="btn btn-ghost" style="width:40px; padding:0; cursor:pointer;"><svg class="icon icon-lg" viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg><input type="file" id="dm-file" accept="image/*" style="display:none" onchange="app.handleFileSelect(this, 'dm')"></label>
                            <input type="text" id="dm-in" class="input" placeholder="メッセージ..." style="margin:0;">
                            <button type="submit" class="btn btn-primary" style="width:50px; padding:0;"><svg class="icon" viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg></button>
                        </form>
                        <div id="dm-preview" style="display:none; padding:10px 15px 0; align-items:center; gap:10px;">
                            <img id="dm-preview-img" class="preview-thumb"><span class="text-xs text-sub">画像</span><button class="btn btn-ghost btn-sm" style="margin-left:auto;" onclick="app.clearDMImg()">取消</button>
                        </div>
                    </div>
                </div>

                <div id="tab-trade" class="scroll-view hidden">
                    <div class="stamp-tabs mb-4">
                        <div class="stamp-tab active" onclick="app.switchTradeTab('exchange')" id="sw-trade-exchange">物々交換所</div>
                        <div class="stamp-tab" onclick="app.switchTradeTab('market')" id="sw-trade-market">フリマ(ショップ)</div>
                    </div>

                    <div id="trade-area-exchange">
                        <div class="card">
                            <div class="flex items-center justify-between mb-2"><h3>出品 (物々交換)</h3><span class="text-xs text-sub">複数選択対応</span></div>
                            <div class="mb-2 font-bold text-sm">【出】 出すもの</div>
                            <div id="tr-give-rows" class="flex flex-col gap-2 mb-2"></div>
                            <div class="flex gap-2 mb-4"><button class="btn btn-ghost btn-sm" style="width:auto" onclick="app.addTradeRow('give')">＋ 追加</button><button class="btn btn-ghost btn-sm" style="width:auto" onclick="app.clearTradeRows('give')">クリア</button></div>
                            <div class="mb-2 font-bold text-sm mt-4">【求】 欲しいもの</div>
                            <div id="tr-want-rows" class="flex flex-col gap-2 mb-2"></div>
                            <div class="flex gap-2 mb-4"><button class="btn btn-ghost btn-sm" style="width:auto" onclick="app.addTradeRow('want')">＋ 追加</button><button class="btn btn-ghost btn-sm" style="width:auto" onclick="app.clearTradeRows('want')">クリア</button></div>
                            <div class="mb-4 mt-2"><input type="text" id="tr-pass" class="input" placeholder="あいことば (任意)"></div>
                            <button class="btn btn-primary" onclick="app.createTrade()">出品を公開</button>
                        </div>
                        <h3>取引一覧</h3><div id="trade-list" class="flex flex-col gap-2"></div>
                    </div>

                    <div id="trade-area-market" class="hidden flex-col gap-4">
                        <div class="card">
                            <h3 class="mb-3">フリマに出品（コインで販売）</h3>
                            <div class="flex gap-2 items-center mb-2">
                                <select id="mk-sell-type" class="input" style="width:40%" onchange="app.onMarketTypeChange()"><option value="item">消費アイテム</option><option value="amulet">お守り</option></select>
                                <div id="mk-sell-valwrap" style="flex:1"></div>
                            </div>
                            <div class="flex gap-2 items-center mb-4"><label class="text-xs text-sub" style="width:40%">販売価格(コイン)</label><input type="number" id="mk-sell-price" class="input" placeholder="例: 1000" min="10"></div>
                            <button class="btn btn-primary" onclick="app.createMarketItem()">出品する</button>
                        </div>
                        <h3>ショップ（出品一覧）</h3><div id="market-list" class="flex flex-col gap-2"></div>
                    </div>
                </div>

                <div id="tab-stamps" class="scroll-view hidden">
                    <div class="card">
                        <h3 class="mb-2">自分の申請パック</h3>
                        <button class="btn btn-primary mb-3" onclick="app.openStampMaker()">＋ 新しくスタンプを作る</button>
                        <div id="stamps-top-list" class="flex flex-col gap-2"></div>
                    </div>
                </div>

                <div id="tab-settings" class="scroll-view hidden">
                    <div class="card">
                        <h3>プロフィール</h3>
                        <div class="mb-4"><label class="text-xs text-sub">表示名</label><input type="text" id="set-name" class="input"></div>
                        <div class="mb-4">
                            <label class="text-xs text-sub">公式バッジ申請</label>
                            <button class="btn btn-ghost btn-sm" style="width:auto; border-color:var(--primary); color:var(--primary)" onclick="app.openBadgeApply()">申請フォームを開く</button>
                        </div>
                        <button class="btn btn-primary" onclick="app.updateProfile()">保存</button>
                    </div>
                    <div class="card" style="border-color:var(--primary)">
                        <h3 style="color:var(--primary)">ゲームデータ同期</h3>
                        <div class="text-xs text-sub mb-3">ブラウザの <b>kb_save_v60</b> を広場へ同期します。<br>※コイン/ダイヤ/レベルは広場側の値を優先します。</div>
                        <div class="flex gap-2 mb-2">
                            <button class="btn btn-primary" onclick="app.importFullFromGame()">📥 取り込む</button>
                            <button class="btn btn-ghost" onclick="app.exportFullToGame()">📤 ゲームへ反映</button>
                        </div>
                    </div>
                    <div class="card">
                        <h3>バックアップと復元</h3>
                        <div class="flex gap-2 mb-2">
                            <button class="btn btn-primary" onclick="app.backupFullGameData()">バックアップ作成</button>
                            <button class="btn btn-danger" onclick="app.restoreCloudList()">履歴から復元</button>
                        </div>
                    </div>
                    <div class="card">
                        <h3>アカウント</h3>
                        <div class="text-xs text-sub mb-4">ID: <span id="set-uid"></span></div>
                        <button class="btn btn-danger" onclick="app.logout()">ログアウト</button>
                    </div>
                    <div class="card">
                        <h3>運営認証</h3>
                        <input type="password" id="adm-code" class="input mb-4" placeholder="運営コード">
                        <button class="btn btn-ghost" onclick="app.authAdmin()">認証</button>
                    </div>
                </div>

                <div id="tab-admin" class="scroll-view hidden">
                    <div class="card" style="border-color:var(--danger)">
                        <h3 style="color:var(--danger)">警察（ユーザー処罰）</h3>
                        <div class="flex gap-2 mb-2">
                            <input type="text" id="adm-police-uid" class="input" placeholder="対象ユーザーID">
                        </div>
                        <div class="flex gap-2">
                            <button class="btn btn-warning btn-sm" onclick="app.applyPenalty('mute')">Mute (チャット禁止)</button>
                            <button class="btn btn-danger btn-sm" onclick="app.applyPenalty('wipe')">Wipe (財産没収)</button>
                            <button class="btn btn-danger btn-sm" onclick="app.applyPenalty('ban')">Ban (凍結)</button>
                        </div>
                        <div class="text-xs text-sub mt-2">※Wipeを行うと、実行時刻以前のバックアップからの復元も無効化されます。</div>
                    </div>
                    <div class="card" style="border-color:var(--primary)">
                        <h3 style="color:var(--primary)">スタンプ審査</h3>
                        <div class="flex gap-2 mb-3">
                            <button class="btn btn-ghost btn-sm" style="width:auto" onclick="app.admLoadStampQueue()">更新</button>
                            <button class="btn btn-ghost btn-sm" style="width:auto" onclick="app.admShowApprovedStamps()">承認済み一覧</button>
                        </div>
                        <div id="adm-stamp-queue"></div>
                    </div>
                    <div class="card" style="border-color:var(--warning)">
                        <h3 style="color:var(--warning)">お知らせ配信</h3>
                        <input type="hidden" id="adm-news-id">
                        <input type="text" id="adm-news-title" class="input mb-2" placeholder="タイトル">
                        <textarea id="adm-news-body" class="input mb-2" style="min-height:80px" placeholder="本文"></textarea>
                        <div class="flex gap-2 items-center mb-2"><label class="btn btn-ghost btn-sm" style="width:auto">画像<input type="file" id="adm-news-file" accept="image/*" style="display:none" onchange="app.handleFileSelect(this, 'news')"></label><span id="adm-news-file-status" class="text-xs text-sub">未選択</span></div>
                        <div class="flex gap-4 items-center mb-4">
                            <label class="flex items-center gap-2 text-sm"><input type="checkbox" id="adm-news-pin"> 固定</label>
                            <div class="flex flex-col"><label class="text-xs text-sub">公開予約</label><input type="datetime-local" id="adm-news-date" class="input" style="width:auto; padding:6px;"></div>
                        </div>
                        <div class="flex gap-2"><button id="btn-news-post" class="btn btn-primary" onclick="app.postNews()">配信登録</button><button id="btn-news-cancel" class="btn btn-ghost hidden" onclick="app.resetNewsForm()">キャンセル</button></div>
                    </div>
                    <div class="card">
                        <h3>プレゼント配布</h3>
                        <input type="hidden" id="adm-gift-id">
                        <div class="flex gap-2 mb-2"><select id="adm-gift-type" class="input"><option value="coins">コイン</option><option value="diamonds">ダイヤ</option></select><input type="number" id="adm-gift-val" class="input" placeholder="量"></div>
                        <input type="text" id="adm-gift-msg" class="input mb-2" placeholder="メッセージ">
                        <div class="flex flex-col gap-2 mb-4">
                            <div class="flex flex-col"><label class="text-xs text-sub">配布開始日時</label><input type="datetime-local" id="adm-gift-start" class="input" style="padding:6px;"></div>
                            <div class="flex flex-col"><label class="text-xs text-sub">受取期限</label><input type="datetime-local" id="adm-gift-end" class="input" style="padding:6px;"></div>
                        </div>
                        <div class="flex gap-2"><button id="btn-gift-post" class="btn btn-danger" onclick="app.distributeGift()">全員に配布</button><button id="btn-gift-cancel" class="btn btn-ghost hidden" onclick="app.resetGiftForm()">キャンセル</button></div>
                    </div>
                    <h3 class="mt-4 mb-2">配信中のお知らせ</h3><div id="adm-list-news"></div>
                    <h3 class="mt-4 mb-2">配布済みギフト</h3><div id="adm-list-gifts"></div>
                </div>
            </div>

            <nav class="bottom-nav">
                <div class="b-nav-item active" onclick="app.tab('home')" data-tab="home"><svg class="icon" viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg><br>ホーム</div>
                <div class="b-nav-item" onclick="app.tab('chat')" data-tab="chat"><svg class="icon" viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/></svg><br>チャット</div>
                <div class="b-nav-item" onclick="app.tab('trade')" data-tab="trade"><svg class="icon" viewBox="0 0 24 24"><path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zM1 2v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1H5.21l-.94-2H1zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2z"/></svg><br>取引所</div>
                <div class="b-nav-item" onclick="app.tab('stamps')" data-tab="stamps"><svg class="icon" viewBox="0 0 24 24"><path d="M22 2H2v20l4-4h16V2zM13 13h-2v-2h2v2zm0-4h-2V7h2v2z"/></svg><br>スタンプ</div>
                <div class="b-nav-item" onclick="app.tab('settings')" data-tab="settings"><svg class="icon" viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L3.16 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.04.64.09.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg><br>設定</div>
            </nav>
        </div>
    </div>

    <div id="modal-base" class="modal-overlay" onclick="if(event.target===this)app.closeModal()">
        <div class="modal-box">
            <div class="modal-head"><span id="mdl-title"></span><button class="btn btn-ghost" style="width:30px;padding:0" onclick="app.closeModal()"><svg class="icon" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg></button></div>
            <div id="mdl-content" class="modal-body"></div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, collection, addDoc, onSnapshot, serverTimestamp, query, limit, where, deleteDoc, Timestamp, getDocs, increment, runTransaction, arrayUnion, writeBatch } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDguL7I5v4GxKf5FahdoFEtU5lNMYgxcNo",
            authDomain: "cotobato-c121f.firebaseapp.com",
            databaseURL: "https://cotobato-c121f-default-rtdb.firebaseio.com",
            projectId: "cotobato-c121f",
            storageBucket: "cotobato-c121f.firebasestorage.app",
            messagingSenderId: "699569737682",
            appId: "1:699569737682:web:350b90c25c300a0548020b"
        };

        const fApp = initializeApp(firebaseConfig);
        const db = getFirestore(fApp);
        const auth = getAuth(fApp);
        const SESS_KEY = "kb_user_id";
        const ADM_KEY = "kb_adm_exp";
        const KB_SAVE_KEY = "kb_save_v60"; 

        let currentUser = null;
        let listeners = [];
        let chatImg = null; let dmImg = null; let newsImg = null; let newsImgOriginal = null;
        let currentRoomId = null; 
        let dmUnsub = null;
        let currentStampTab = 'public';
        const PK_DRAFT_KEY = 'kb_stamp_pack_draft_v1';
        let actionMsg = null; let replyTarget = { all: null, dm: null };
        const appCache = { news: {}, chat: {}, gifts: {} }; 
        const toDate = (ts) => { if (!ts) return new Date(); if (ts.toDate) return ts.toDate(); if (ts instanceof Date) return ts; return new Date(); };
        const safeArgs = (s) => s ? s.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/\n/g, '\\n') : '';

        // WebRTC variables
        let peer = null; let incomingCallObj = null; let callStatus = 'idle'; let localStream = null; let remoteStream = null; let currentCall = null;

        // Static Game Data for Trading/Market
        const G_ITEMS = [
            { id: 'potion1', name: 'ちょこっと回復薬', icon:'<svg class="icon" viewBox="0 0 24 24"><path d="M12 2l-5.5 9h11z"/><path d="M10 12h4v4h-4z"/></svg>' },
            { id: 'potion2', name: 'ちゃっかり回復薬', icon:'<svg class="icon" viewBox="0 0 24 24"><path d="M12 2l-5.5 9h11z"/><path d="M9 12h6v6h-6z"/></svg>' },
            { id: 'potion3', name: 'もりもり回復薬', icon:'<svg class="icon" viewBox="0 0 24 24"><path d="M12 2l-5.5 9h11z"/><path d="M8 12h8v8h-8z"/></svg>' },
            { id: 'skip', name: 'スキップ', icon:'<svg class="icon" viewBox="0 0 24 24"><path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/></svg>' },
            { id: 'morning_call', name: 'アサニナ～ル', icon:'<svg class="icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"/><path d="M12 1v2m0 18v2M4.22 4.22l1.42 1.42m12.72 12.72l1.42 1.42M1 12h2m18 0h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg>' },
            { id: 'night_call', name: 'ヨルニナ～ル', icon:'<svg class="icon" viewBox="0 0 24 24"><path d="M12 3a9 9 0 1 0 9 9c0-.46-.04-.92-.1-1.36a5.389 5.389 0 0 1-4.4 2.26 5.403 5.403 0 0 1-3.14-9.8c-.44-.06-.9-.1-1.36-.1z"/></svg>' },
            { id: 'hina_heart', name: 'ひなの気持ち', icon:'<svg class="icon" viewBox="0 0 24 24" fill="#da3633"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>' }
        ];
        const G_AMULETS = [
            { id: 'amulet_hp', name: '再生のお守り', icon:'<svg class="icon" viewBox="0 0 24 24"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z"/></svg>', durability: 100 },
            { id: 'amulet_rich', name: '富豪のお守り', icon:'<svg class="icon" viewBox="0 0 24 24"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 6c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3z"/></svg>', durability: 200 },
            { id: 'amulet_drop', name: '幸運のお守り', icon:'<svg class="icon" viewBox="0 0 24 24"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z"/><circle cx="12" cy="12" r="3" fill="#fff"/></svg>', durability: 200 },
            { id: 'amulet_pow', name: '力の指輪', icon:'<svg class="icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="8" stroke="currentColor" fill="none" stroke-width="2"/></svg>', durability: 200 },
            { id: 'amulet_def', name: '守りの盾', icon:'<svg class="icon" viewBox="0 0 24 24"><path d="M12 2L4 5v6.09c0 5.05 3.41 9.76 8 10.91 4.59-1.15 8-5.86 8-10.91V5l-8-3z"/></svg>', durability: 200 },
            { id: 'amulet_poison1', name: '毒除けI', icon:'<svg class="icon" viewBox="0 0 24 24"><path d="M10 2v3h4V2H10zM5 7v15h14V7H5z"/></svg>', durability: 150 },
            { id: 'amulet_poison2', name: '毒除けII', icon:'<svg class="icon" viewBox="0 0 24 24"><path d="M10 2v3h4V2H10zM5 7v15h14V7H5z"/></svg>', durability: 200 },
            { id: 'amulet_poison3', name: '毒除け完全', icon:'<svg class="icon" viewBox="0 0 24 24"><path d="M10 2v3h4V2H10zM5 7v15h14V7H5z"/></svg>', durability: 300 },
            { id: 'amulet_burn1', name: '火除けI', icon:'<svg class="icon" viewBox="0 0 24 24"><path d="M12 2c-4 4-5.5 6-5.5 9 0 3 2.5 5.5 5.5 5.5s5.5-2.5 5.5-5.5C17.5 8 16 6 12 2z"/></svg>', durability: 150 },
            { id: 'amulet_burn2', name: '火除けII', icon:'<svg class="icon" viewBox="0 0 24 24"><path d="M12 2c-4 4-5.5 6-5.5 9 0 3 2.5 5.5 5.5 5.5s5.5-2.5 5.5-5.5C17.5 8 16 6 12 2z"/></svg>', durability: 200 },
            { id: 'amulet_burn3', name: '火除け完全', icon:'<svg class="icon" viewBox="0 0 24 24"><path d="M12 2c-4 4-5.5 6-5.5 9 0 3 2.5 5.5 5.5 5.5s5.5-2.5 5.5-5.5C17.5 8 16 6 12 2z"/></svg>', durability: 300 }
        ];
        const getMeta = (type, id) => {
            if(type==='item') return G_ITEMS.find(c=>c.id===id) || {name:id, icon:''};
            if(type==='amulet') return G_AMULETS.find(c=>c.id===id) || {name:id, icon:''};
            return {name:id, icon:''};
        };

        const app = {
            pkDraft: { id: null, title: '', isPublic: true, isPaid: false, price: 0, mainDataUrl: '', stamps: [] },
            lastChatTime: 0,
            
            init: () => {
                setTimeout(() => {
                    if(document.getElementById('splash-screen').style.display !== 'none') {
                        document.getElementById('splash-screen').style.display = 'none';
                        if(!document.querySelector('.screen.active')) document.getElementById('scr-login').classList.add('active');
                    }
                }, 5000);

                signInAnonymously(auth).then(() => {
                    onAuthStateChanged(auth, u => { if(u) {
                        const uid = localStorage.getItem(SESS_KEY);
                        if(uid) app.loadUser(uid);
                        else {
                            document.getElementById('splash-screen').classList.add('fade-out');
                            setTimeout(() => document.getElementById('splash-screen').style.display = 'none', 500);
                        }
                    }});
                }).catch(e => { console.error(e); document.getElementById('splash-screen').style.display='none'; });
            },
            go: (id) => { document.querySelectorAll('.screen').forEach(e=>e.classList.remove('active')); document.getElementById(id).classList.add('active'); },
            tab: (id) => {
                ['home','chat','trade','stamps','settings','admin'].forEach(t=>{const e=document.getElementById('tab-'+t); if(e) e.classList.add('hidden')});
                const t = document.getElementById('tab-'+id);
                if(t){ t.classList.remove('hidden'); if(t.classList.contains('scroll-view')) t.classList.add('flex-col','flex'); }
                if(id==='chat') { t.style.display='flex'; document.body.classList.add('chat-mode'); app.switchChatMode('all'); } else document.body.classList.remove('chat-mode');
                if(id==='trade') { try { app.initTradeUI(); app.onMarketTypeChange(); } catch(e) {} }
                if(id==='stamps') { try { app.loadMyStampsTop(); } catch(e) {} }
                if(id==='admin') { if(!app.checkAdmSess()) { app.tab('settings'); return; } else { app.admLoadStampQueue(); app.subAdmList(); } }
                document.querySelectorAll('.nav-link, .b-nav-item').forEach(e=>e.classList.remove('active'));
                document.querySelectorAll(`[data-tab="${id}"]`).forEach(e=>e.classList.add('active'));
            },
            
            login: async () => {
                const uid = document.getElementById('inp-uid').value.trim(), pass = document.getElementById('inp-pass').value.trim();
                const btn = document.getElementById('btn-login'); // Fixed: defined btn variable
                if(!uid || !pass) return app.toast("入力してください");
                
                //btn.disabled = true; btn.innerText = "接続中...";
                try {
                    const s = await getDoc(doc(db,"users",uid));
                    if(s.exists() && s.data().password === pass) { 
                        localStorage.setItem(SESS_KEY, uid); app.loadUser(uid); 
                    } else { 
                        app.toast("IDまたはパスワードが違います");
                        //btn.disabled = false; btn.innerText = "ログイン";
                    }
                } catch(e) { 
                    app.toast("接続エラー");
                    //btn.disabled = false; btn.innerText = "ログイン";
                }
            },
            register: async () => {
                const uid = document.getElementById('reg-uid').value.trim();
                const name = document.getElementById('reg-name').value.trim()||uid;
                const pass = document.getElementById('reg-pass').value.trim();
                const sq = document.getElementById('reg-q').value;
                const sa = document.getElementById('reg-a').value.trim();
                if(!uid || !pass) return app.toast("IDとパスワードは必須です");
                if(!sa) return app.toast("秘密の質問の答えを入力してください");
                try {
                    const s = await getDoc(doc(db,"users",uid));
                    if(s.exists()) return app.toast("既に使用されています");
                    await setDoc(doc(db,"users",uid), { 
                        uid, username:uid, name, password:pass, secretQ:sq, secretA:sa,
                        coins:100, diamonds:0, level:1, badges: [], purchasedPacks: [], createdAt:serverTimestamp(), friends:[], history:[]
                    });
                    localStorage.setItem(SESS_KEY, uid); app.loadUser(uid);
                } catch(e) { app.toast("登録エラー"); }
            },
            loadUser: async (uid) => {
                listeners.push(onSnapshot(doc(db,"users",uid), async s=>{
                    if(s.exists()){ 
                        currentUser=s.data(); 
                        if(currentUser.isBanned) { app.toast('アカウントが凍結されています'); app.logout(); return; }
                        
                        document.getElementById('splash-screen').classList.add('fade-out');
                        setTimeout(() => document.getElementById('splash-screen').style.display = 'none', 500);
                        app.go('scr-main'); 
                        if(document.querySelectorAll('.screen.active').length <= 1) app.tab('home');

                        app.renderHead(); app.checkAdmSess();
                        if(!peer) app.initPeer(currentUser.username);
                        app.checkAutoBadges().catch(e => console.error("Badge check error", e));
                        
                        app.subNews(); app.subChat(); app.subTrade(); app.subMarket(); app.subDMList(uid); app.subRequests(uid);
                    } else { localStorage.removeItem(SESS_KEY); location.reload(); }
                }));
            },
            logout: () => { localStorage.removeItem(SESS_KEY); localStorage.removeItem(ADM_KEY); location.reload(); },

            // Badges & Apply
            checkAutoBadges: async () => {
                if(!currentUser) return;
                const b = currentUser.badges || [];
                let added = false;
                const add = (id) => { if(!b.includes(id)) { b.push(id); added=true; } };
                if((currentUser.level||1) >= 10) add('level10');
                if((currentUser.level||1) >= 30) add('level30');
                if((currentUser.coins||0) >= 100000) add('rich');
                if((currentUser.diamonds||0) >= 1000) add('whale');
                if(added) await updateDoc(doc(db, "users", currentUser.username), { badges: b });
            },
            getBadgesHtml: (bArr) => {
                let b = bArr || []; let html = "";
                if(b.includes('developer')) html += `<span class="badge badge-developer">開発者</span>`;
                if(b.includes('staff')) html += `<span class="badge badge-staff">関係者</span>`;
                if(b.includes('bug')) html += `<span class="badge badge-bug">バグ発見者</span>`;
                if(b.includes('vip')) html += `<span class="badge badge-vip">VIP</span>`;
                if(b.includes('veteran')) html += `<span class="badge badge-veteran">古参</span>`;
                if(b.includes('official')) html += `<span class="badge badge-official">公式</span>`;
                if(b.includes('level30')) html += `<span class="badge badge-level">Lv.30+</span>`;
                else if(b.includes('level10')) html += `<span class="badge badge-level">Lv.10+</span>`;
                if(b.includes('rich')) html += `<span class="badge badge-rich">富豪</span>`;
                if(b.includes('whale')) html += `<span class="badge badge-whale">💎大富豪</span>`;
                return html;
            },
            openBadgeApply: () => {
                const h = `<div class="mb-2">活動内容や外部リンクを入力してください。運営が審査します。</div>
                <textarea id="badge-apply-reason" class="input mb-2" placeholder="申請理由、YouTube/Twitterリンクなど" style="min-height:100px"></textarea>
                <button class="btn btn-primary" onclick="app.submitBadgeApply()">申請する</button>`;
                app.mdl("公式バッジ申請", h);
            },
            submitBadgeApply: async () => {
                const r = document.getElementById('badge-apply-reason').value.trim();
                if(!r) return;
                await addDoc(collection(db, "admin_requests"), { type: 'badge', uid: currentUser.username, name: currentUser.name, reason: r, status: 'pending', createdAt: serverTimestamp() });
                app.toast("申請しました"); app.closeModal();
            },
            renderHead: () => {
                document.getElementById('header-user-name').innerText=currentUser.name; document.getElementById('set-name').value=currentUser.name; 
                document.getElementById('set-uid').innerText = currentUser.username;
                document.getElementById('profile-badges-top').innerHTML = app.getBadgesHtml(currentUser.badges);
                document.getElementById('v-coin').innerText=(currentUser.coins||0).toLocaleString(); 
                document.getElementById('v-gem').innerText=(currentUser.diamonds||0).toLocaleString(); 
                document.getElementById('v-level').innerText=currentUser.level||1;
            },
            updateProfile: async () => {
                const name = document.getElementById('set-name').value.trim();
                if(!name) return;
                await updateDoc(doc(db, "users", currentUser.username), { name: name });
                app.toast("更新しました");
            },

            // Chat All (with Anti-Abuse) - FIXED
            subChat: () => {
                if(listeners.chat) return;
                listeners.chat = onSnapshot(query(collection(db,"chat"), limit(50)), s=>{
                    const b = document.getElementById('chat-box'); b.innerHTML="";
                    let msgs=[]; s.forEach(d=>{ const m=d.data(); m.id=d.id; appCache.chat[d.id]=m; msgs.push(m); });
                    msgs.sort((a,b)=>(a.createdAt?.seconds||0) - (b.createdAt?.seconds||0));
                    msgs.forEach(m => b.innerHTML += app.buildMsgHTML(m, false));
                    if(!document.getElementById('tab-chat').classList.contains('hidden')) setTimeout(()=>b.scrollTop=99999, 100);
                });
            },
            sendChat: async (stampUrl = null) => {
                if(currentUser.isMuted) return app.toast('チャットが制限されています');
                const now = Date.now();
                if(now - app.lastChatTime < 1000) return app.toast('送信が早すぎます');
                
                const i=document.getElementById('chat-in'), t=i.value.trim(); const imgPayload = stampUrl || chatImg;
                if(!t && !imgPayload) return;
                
                // Simple NG Word Check
                const ngWords = ['死ね','殺す','馬鹿','アホ','カス','ゴミ','fuck','shit'];
                if(ngWords.some(w => t.includes(w))) return app.toast('不適切な言葉が含まれています');

                app.lastChatTime = now;
                const payload = { text:t, img:imgPayload, username:currentUser.username, sender:currentUser.name, createdAt:serverTimestamp() };
                if(replyTarget.all) { payload.replyTo = replyTarget.all; }
                await addDoc(collection(db,"chat"), payload);
                i.value=""; app.clearChatImg(); app.cancelReply('all');
            },
            buildMsgHTML: (m, isDm = false) => {
                const isMe = m.username === currentUser.username;
                const name = m.sender || "Unknown";
                const type = isDm ? 'dm' : 'all';
                let replyHtml = '';
                if(m.replyTo) {
                    const r = m.replyTo;
                    const rText = r.text ? (r.text.length > 20 ? r.text.substring(0,20)+'...' : r.text) : (r.img ? '画像' : '');
                    replyHtml = `<div class="reply-box-in-msg">${r.img ? `<img src="${r.img}">` : ''}<div class="reply-content"><div style="font-size:0.65rem; color:var(--primary)">${r.name}</div><div>${rText}</div></div></div>`;
                }
                // Use Cache-based openMsgAction call to prevent HTML breakage
                const tapAction = `app.openMsgAction('${type}', '${m.id}', '${currentRoomId||''}')`;
                let contentHtml = '';
                if (m.text) contentHtml += `<div>${m.text}</div>`;
                if (m.img) {
                    const isStamp = !m.text && m.img;
                    const imgClick = isStamp ? "" : `onclick="event.stopPropagation(); document.getElementById('img-full').src=this.src;document.getElementById('img-viewer').style.display='flex'"`;
                    contentHtml += `<img src="${m.img}" class="${m.text?'chat-img':'stamp-img chat-img'}" ${imgClick}>`;
                }
                return `<div class="msg-row ${isMe?'mine':'other'}">
                    ${!isMe?`<span class="msg-name" onclick="app.showProfile('${m.username}','${name.replace(/'/g,"\\'")}')">${name}</span>`:''}
                    <div class="msg-bubble" style="${!m.text && m.img ? 'background:transparent; border:none; padding:0;' : ''}" onclick="${tapAction}">${replyHtml}${contentHtml}</div>
                </div>`;
            },
            // ... (Other functions like DM, WebRTC, Stamp Maker remain standard)

            // Pass Reset
            checkSecurityQuestion: async () => {
                const uid = document.getElementById('rst-uid').value.trim();
                if(!uid) return app.toast("IDを入力してください");
                try {
                    const snap = await getDoc(doc(db, "users", uid));
                    if(!snap.exists()) return app.toast("ユーザーが見つかりません");
                    const d = snap.data();
                    if(!d.secretQ) return app.toast("秘密の質問が未設定です");
                    const qText = { pet: "初めて飼ったペットの名前は？", school: "小学校の名前は？", mother: "母親の旧姓は？", food: "好きな食べ物は？" }[d.secretQ] || "秘密の質問";
                    document.getElementById('rst-q-text').innerText = qText;
                    document.getElementById('rst-step-1').classList.add('hidden');
                    document.getElementById('rst-step-2').classList.remove('hidden');
                    app.resetTargetUid = uid;
                } catch(e) { app.toast("エラー"); }
            },
            doResetPass: async () => {
                const ans = document.getElementById('rst-ans').value.trim();
                const newPass = document.getElementById('rst-new-pass').value.trim();
                if(!ans || !newPass) return app.toast("全て入力してください");
                try {
                    const snap = await getDoc(doc(db, "users", app.resetTargetUid));
                    if(snap.data().secretA === ans) {
                        await updateDoc(doc(db, "users", app.resetTargetUid), { password: newPass });
                        app.toast("パスワードを変更しました"); app.go('scr-login');
                    } else app.toast("答えが違います");
                } catch(e) {}
            },
            togglePass: (id, btn) => {
                const el = document.getElementById(id);
                if(el) { const isPass = el.type === 'password'; el.type = isPass ? 'text' : 'password'; 
                btn.innerHTML = isPass ? '<svg class="icon" viewBox="0 0 24 24"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>' : '<svg class="icon" viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>'; }
            },

            // Profile & Manage Badges
            showProfile: async (uid, name) => {
                if(uid === currentUser.username) return;
                try {
                    const snap = await getDoc(doc(db, "users", uid));
                    if(!snap.exists()) return app.toast("ユーザーが見つかりません");
                    const target = snap.data();
                    const isFriend = currentUser.friends && currentUser.friends.includes(uid);
                    let btnHtml = isFriend ? `<button class="btn btn-success mt-2" onclick="app.startDM('${uid}', '${name.replace(/'/g,"\\'")}')">チャットする</button>` : `<button class="btn btn-primary mt-2" onclick="app.sendRequest('${uid}')">友達申請する</button>`;
                    
                    const myB = currentUser.badges || [];
                    if(app.checkAdmSess() || myB.includes('developer') || myB.includes('staff')) {
                        btnHtml += `<button class="btn btn-warning mt-2" onclick="app.manageBadges('${uid}')">バッジを管理する</button>`;
                    }
                    app.mdl("プロフィール", `<div style="text-align:center"><div style="font-size:3rem; margin-bottom:10px;"><svg class="icon icon-xl" viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg></div><h3>${target.name}</h3><div class="mb-2">${app.getBadgesHtml(target.badges)}</div><p class="text-sub text-xs mb-4">ID: ${uid}</p>${btnHtml}</div>`);
                } catch(e) {}
            },
            manageBadges: async (targetUid) => {
                const s = await getDoc(doc(db, "users", targetUid));
                if(!s.exists()) return;
                const t = s.data(); const b = t.badges || [];
                let html = `<div class="flex flex-col gap-3 mb-4">
                    <label><input type="checkbox" id="mb-dev" ${b.includes('developer')?'checked':''}> 開発者</label>
                    <label><input type="checkbox" id="mb-staff" ${b.includes('staff')?'checked':''}> 関係者</label>
                    <label><input type="checkbox" id="mb-bug" ${b.includes('bug')?'checked':''}> バグ発見者</label>
                    <label><input type="checkbox" id="mb-vip" ${b.includes('vip')?'checked':''}> VIP</label>
                    <label><input type="checkbox" id="mb-veteran" ${b.includes('veteran')?'checked':''}> 古参</label>
                    <label><input type="checkbox" id="mb-official" ${b.includes('official')?'checked':''}> 公式</label>
                </div>
                <button class="btn btn-warning" onclick="app.saveManagedBadges('${targetUid}')">保存</button>`;
                app.mdl("バッジ管理: " + t.name, html);
            },
            saveManagedBadges: async (targetUid) => {
                const s = await getDoc(doc(db, "users", targetUid));
                if(!s.exists()) return;
                const b = s.data().badges || [];
                const handBadges = ['developer','staff','bug','vip','veteran','official'];
                const newB = b.filter(x => !handBadges.includes(x));
                if(document.getElementById('mb-dev').checked) newB.push('developer');
                if(document.getElementById('mb-staff').checked) newB.push('staff');
                if(document.getElementById('mb-bug').checked) newB.push('bug');
                if(document.getElementById('mb-vip').checked) newB.push('vip');
                if(document.getElementById('mb-veteran').checked) newB.push('veteran');
                if(document.getElementById('mb-official').checked) newB.push('official');
                await updateDoc(doc(db, "users", targetUid), { badges: newB });
                app.toast("更新しました"); app.closeModal(); app.showProfile(targetUid, s.data().name);
            },

            // WebRTC Call
            initPeer: (uid) => {
                if(peer) return;
                try {
                    peer = new Peer(uid);
                    peer.on('call', (c) => {
                        if(callStatus!=='idle'){c.close();return;}
                        incomingCallObj=c; callStatus='incoming';
                        const m=c.metadata||{}; document.getElementById('inc-call-name').innerText=m.name||c.peer; document.getElementById('inc-call-type').innerText=m.video?'ビデオ':'音声';
                        app.go('scr-call'); document.getElementById('call-ui-incoming').classList.remove('hidden'); document.getElementById('call-ui-calling').classList.add('hidden'); document.getElementById('call-ui-connected').classList.add('hidden');
                        c.on('close',()=>app.endCall()); c.on('error',()=>app.endCall());
                    });
                    peer.on('error',e=>{ if(e.type==='unavailable-id') app.toast("通話ID重複");});
                } catch(e){}
            },
            startCall: async (videoEnabled) => {
                if(callStatus !== 'idle') return app.toast("通話中です");
                if(!currentRoomId) return;
                const targetUid = currentRoomId.split('_').find(m => m !== currentUser.username);
                if(!targetUid) return;
                callStatus = 'calling'; app.go('scr-call');
                document.getElementById('call-ui-calling').classList.remove('hidden'); document.getElementById('call-ui-incoming').classList.add('hidden'); document.getElementById('call-ui-connected').classList.add('hidden');
                document.getElementById('call-name').innerText = document.getElementById('dm-talk-name').innerText;
                document.getElementById('remote-video').srcObject = null; document.getElementById('local-video').srcObject = null;
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: videoEnabled });
                    document.getElementById('local-video').srcObject = localStream; document.getElementById('local-video').muted = true;
                    if(videoEnabled) document.getElementById('local-video').classList.add('active');
                    if(!peer) app.initPeer(currentUser.username);
                    const call = peer.call(targetUid, localStream, { metadata: { name: currentUser.name, video: videoEnabled } });
                    currentCall = call;
                    call.on('stream', (remote) => {
                        remoteStream = remote; document.getElementById('remote-video').srcObject = remote; callStatus = 'connected';
                        document.getElementById('call-ui-calling').classList.add('hidden'); document.getElementById('call-ui-connected').classList.remove('hidden');
                        document.getElementById('remote-video').play().catch(e=>{});
                    });
                    call.on('close', () => app.endCall()); call.on('error', () => app.endCall());
                } catch(e) { app.toast("エラー"); app.endCall(); }
            },
            answerCall: async () => {
                if(!incomingCallObj) return;
                try {
                    const videoEnabled = incomingCallObj.metadata ? incomingCallObj.metadata.video : false;
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: videoEnabled });
                    document.getElementById('local-video').srcObject = localStream; document.getElementById('local-video').muted = true;
                    if(videoEnabled) document.getElementById('local-video').classList.add('active');
                    incomingCallObj.answer(localStream); currentCall = incomingCallObj; callStatus = 'connected';
                    document.getElementById('call-ui-incoming').classList.add('hidden'); document.getElementById('call-ui-connected').classList.remove('hidden');
                    currentCall.on('stream', (remote) => {
                        remoteStream = remote; document.getElementById('remote-video').srcObject = remote;
                        document.getElementById('remote-video').play().catch(e=>{});
                    });
                    currentCall.on('close', () => app.endCall()); currentCall.on('error', () => app.endCall());
                } catch(e) { app.endCall(); }
            },
            endCall: () => {
                if(currentCall) currentCall.close(); if(incomingCallObj) incomingCallObj.close();
                if(localStream) localStream.getTracks().forEach(t => t.stop());
                currentCall = null; incomingCallObj = null; localStream = null; remoteStream = null; callStatus = 'idle';
                if(currentRoomId) app.go('scr-dm-talk'); else app.tab('home');
            },
            toggleMic: () => { if(localStream) { const t = localStream.getAudioTracks()[0]; if(t) { t.enabled = !t.enabled; document.getElementById('btn-mic-toggle').classList.toggle('active', t.enabled); } } },
            toggleVideo: async () => { app.toast("ビデオ切替"); },

            // Friends & DM (Inline Request)
            searchUserForFriendInline: async () => {
                const tid = document.getElementById('inline-friend-id').value.trim();
                const resDiv = document.getElementById('inline-friend-result');
                if(!tid) return;
                if(tid === currentUser.username) return resDiv.innerHTML="<span class='text-warning text-xs'>自分自身です</span>";
                resDiv.innerHTML = "";
                try {
                    const snap = await getDoc(doc(db, "users", tid));
                    if(!snap.exists()) return resDiv.innerHTML="<span class='text-danger text-xs'>見つかりません</span>";
                    const t = snap.data();
                    resDiv.innerHTML = `<div class="p-3 border border-[var(--primary)] rounded mt-2">
                        <div class="font-bold">${t.name} ${app.getBadgesHtml(t.badges)}</div><div class="text-xs text-sub mb-2">ID: ${tid}</div>
                        <button class="btn btn-success btn-sm w-full" onclick="app.sendRequest('${tid}')">申請を送る</button></div>`;
                } catch(e) { resDiv.innerHTML="エラー"; }
            },
            sendRequest: async (targetId) => {
                if(targetId === currentUser.username) return;
                try {
                    const snap = await getDoc(doc(db, "users", targetId));
                    if(!snap.exists()) return app.toast("見つかりません");
                    const exist = await getDocs(query(collection(db, "requests"), where("from", "==", currentUser.username), where("to", "==", targetId)));
                    if(!exist.empty) return app.toast("申請済みです");
                    if(currentUser.friends && currentUser.friends.includes(targetId)) return app.toast("既に友達です");
                    await addDoc(collection(db, "requests"), { from: currentUser.username, fromName: currentUser.name, to: targetId, toName: snap.data().name, status: 'pending', createdAt: serverTimestamp() });
                    app.toast("申請を送りました");
                } catch(e) {}
            },
            subRequests: (uid) => {
                listeners.push(onSnapshot(query(collection(db, "requests"), where("to", "==", uid)), s => {
                    const list = document.getElementById('requests-list'); list.innerHTML = "";
                    s.forEach(d => {
                        const r = d.data();
                        list.innerHTML += `<div class="flex justify-between items-center mb-2 pb-2 border-b border-[var(--border)]"><div><div class="font-bold text-sm">${r.fromName}</div><div class="text-xs text-sub">ID: ${r.from}</div></div><div class="flex gap-2"><button class="btn btn-sm btn-primary" onclick="app.acceptRequest('${d.id}', '${r.from}')">承認</button><button class="btn btn-sm btn-danger" onclick="app.rejectRequest('${d.id}')">拒否</button></div></div>`;
                    });
                }));
                listeners.push(onSnapshot(query(collection(db, "requests"), where("from", "==", uid)), s => {
                    const list = document.getElementById('outgoing-list'); list.innerHTML = "";
                    s.forEach(d => {
                        list.innerHTML += `<div class="flex justify-between items-center mb-2"><div class="text-sm">${d.data().toName} へ送信中</div><button class="btn btn-sm btn-danger" onclick="app.rejectRequest('${d.id}')">取消</button></div>`;
                    });
                }));
            },
            acceptRequest: async (reqId, fromUid) => {
                try {
                    await runTransaction(db, async tr => {
                        tr.update(doc(db, "users", currentUser.username), { friends: arrayUnion(fromUid) });
                        tr.update(doc(db, "users", fromUid), { friends: arrayUnion(currentUser.username) });
                        tr.delete(doc(db, "requests", reqId));
                    });
                    app.toast("友達になりました！");
                } catch(e) {}
            },
            rejectRequest: async (reqId) => { await deleteDoc(doc(db, "requests", reqId)); },
            subDMList: (uid) => {
                listeners.push(onSnapshot(doc(db, "users", uid), async s => {
                    if (!s.exists()) return;
                    const friends = s.data().friends || [];
                    const list = document.getElementById('dm-list-box'); list.innerHTML = "";
                    for(const fid of friends) {
                        try {
                            const fSnap = await getDoc(doc(db, "users", fid));
                            if(fSnap.exists()) {
                                const fData = fSnap.data();
                                list.innerHTML += `<div class="dm-item" onclick="app.startDM('${fid}', '${fData.name.replace(/'/g,"\\'")}')"><div class="dm-icon">${fData.name.charAt(0)}</div><div><div class="font-bold text-sm">${fData.name} ${app.getBadgesHtml(fData.badges)}</div><div class="text-xs text-sub">ID: ${fid}</div></div></div>`;
                            }
                        } catch(e) {}
                    }
                }));
            },
            startDM: async (targetUid, targetName) => {
                app.closeModal(); 
                const members = [currentUser.username, targetUid].sort(), roomId = members.join("_"), ref = doc(db, "rooms", roomId);
                const snap = await getDoc(ref);
                if(!snap.exists()) await setDoc(ref, { members: members, names: { [currentUser.username]: currentUser.name, [targetUid]: targetName }, updatedAt: serverTimestamp() });
                currentRoomId = roomId; document.getElementById('dm-talk-name').innerText = targetName; document.getElementById('scr-dm-talk').classList.add('active');
                if(dmUnsub) dmUnsub();
                dmUnsub = onSnapshot(query(collection(db, "rooms", roomId, "messages"), limit(50)), s => {
                    const b = document.getElementById('dm-talk-box'); b.innerHTML = "";
                    let msgs = []; s.forEach(d => msgs.push({id:d.id, ...d.data()})); msgs.sort((a,b)=>(a.createdAt?.seconds||0) - (b.createdAt?.seconds||0));
                    msgs.forEach(m => b.innerHTML += app.buildMsgHTML(m, true));
                    setTimeout(()=>b.scrollTop = 99999, 100);
                });
            },
            closeDM: () => { document.getElementById('scr-dm-talk').classList.remove('active'); if(dmUnsub) dmUnsub(); currentRoomId = null; app.cancelReply('dm'); },
            sendDM: async (stampUrl = null) => {
                const i = document.getElementById('dm-in'), t = i.value.trim(); const imgPayload = stampUrl || dmImg;
                if((!t && !imgPayload) || !currentRoomId) return;
                const payload = { text: t, img: imgPayload, username: currentUser.username, sender: currentUser.name, createdAt: serverTimestamp() };
                if(replyTarget.dm) { payload.replyTo = replyTarget.dm; }
                await addDoc(collection(db, "rooms", currentRoomId, "messages"), payload);
                i.value = ""; app.clearDMImg(); app.cancelReply('dm');
            },

            // Chat All (with Anti-Abuse) - FIXED
            subChat: () => {
                if(listeners.chat) return;
                listeners.chat = onSnapshot(query(collection(db,"chat"), limit(50)), s=>{
                    const b = document.getElementById('chat-box'); b.innerHTML="";
                    let msgs=[]; s.forEach(d=>{ const m=d.data(); m.id=d.id; appCache.chat[d.id]=m; msgs.push(m); });
                    msgs.sort((a,b)=>(a.createdAt?.seconds||0) - (b.createdAt?.seconds||0));
                    msgs.forEach(m => b.innerHTML += app.buildMsgHTML(m, false));
                    if(!document.getElementById('tab-chat').classList.contains('hidden')) setTimeout(()=>b.scrollTop=99999, 100);
                });
            },
            sendChat: async (stampUrl = null) => {
                if(currentUser.isMuted) return app.toast('チャットが制限されています');
                const now = Date.now();
                if(now - app.lastChatTime < 1000) return app.toast('送信が早すぎます');
                
                const i=document.getElementById('chat-in'), t=i.value.trim(); const imgPayload = stampUrl || chatImg;
                if(!t && !imgPayload) return;
                
                // Simple NG Word Check
                const ngWords = ['死ね','殺す','馬鹿','アホ','カス','ゴミ','fuck','shit'];
                if(ngWords.some(w => t.includes(w))) return app.toast('不適切な言葉が含まれています');

                app.lastChatTime = now;
                const payload = { text:t, img:imgPayload, username:currentUser.username, sender:currentUser.name, createdAt:serverTimestamp() };
                if(replyTarget.all) { payload.replyTo = replyTarget.all; }
                await addDoc(collection(db,"chat"), payload);
                i.value=""; app.clearChatImg(); app.cancelReply('all');
            },
            buildMsgHTML: (m, isDm = false) => {
                const isMe = m.username === currentUser.username;
                const name = m.sender || "Unknown";
                const type = isDm ? 'dm' : 'all';
                let replyHtml = '';
                if(m.replyTo) {
                    const r = m.replyTo;
                    const rText = r.text ? (r.text.length > 20 ? r.text.substring(0,20)+'...' : r.text) : (r.img ? '画像' : '');
                    replyHtml = `<div class="reply-box-in-msg">${r.img ? `<img src="${r.img}">` : ''}<div class="reply-content"><div style="font-size:0.65rem; color:var(--primary)">${r.name}</div><div>${rText}</div></div></div>`;
                }
                // Use Cache-based openMsgAction call to prevent HTML breakage
                const tapAction = `app.openMsgAction('${type}', '${m.id}', '${currentRoomId||''}')`;
                let contentHtml = '';
                if (m.text) contentHtml += `<div>${m.text}</div>`;
                if (m.img) {
                    const isStamp = !m.text && m.img;
                    const imgClick = isStamp ? "" : `onclick="event.stopPropagation(); document.getElementById('img-full').src=this.src;document.getElementById('img-viewer').style.display='flex'"`;
                    contentHtml += `<img src="${m.img}" class="${m.text?'chat-img':'stamp-img chat-img'}" ${imgClick}>`;
                }
                return `<div class="msg-row ${isMe?'mine':'other'}">
                    ${!isMe?`<span class="msg-name" onclick="app.showProfile('${m.username}','${name.replace(/'/g,"\\'")}')">${name}</span>`:''}
                    <div class="msg-bubble" style="${!m.text && m.img ? 'background:transparent; border:none; padding:0;' : ''}" onclick="${tapAction}">${replyHtml}${contentHtml}</div>
                </div>`;
            },
            // ... (Other functions like DM, WebRTC, Stamp Maker remain standard)

            // Pass Reset
            checkSecurityQuestion: async () => {
                const uid = document.getElementById('rst-uid').value.trim();
                if(!uid) return app.toast("IDを入力してください");
                try {
                    const snap = await getDoc(doc(db, "users", uid));
                    if(!snap.exists()) return app.toast("ユーザーが見つかりません");
                    const d = snap.data();
                    if(!d.secretQ) return app.toast("秘密の質問が未設定です");
                    const qText = { pet: "初めて飼ったペットの名前は？", school: "小学校の名前は？", mother: "母親の旧姓は？", food: "好きな食べ物は？" }[d.secretQ] || "秘密の質問";
                    document.getElementById('rst-q-text').innerText = qText;
                    document.getElementById('rst-step-1').classList.add('hidden');
                    document.getElementById('rst-step-2').classList.remove('hidden');
                    app.resetTargetUid = uid;
                } catch(e) { app.toast("エラー"); }
            },
            doResetPass: async () => {
                const ans = document.getElementById('rst-ans').value.trim();
                const newPass = document.getElementById('rst-new-pass').value.trim();
                if(!ans || !newPass) return app.toast("全て入力してください");
                try {
                    const snap = await getDoc(doc(db, "users", app.resetTargetUid));
                    if(snap.data().secretA === ans) {
                        await updateDoc(doc(db, "users", app.resetTargetUid), { password: newPass });
                        app.toast("パスワードを変更しました"); app.go('scr-login');
                    } else app.toast("答えが違います");
                } catch(e) {}
            },
            togglePass: (id, btn) => {
                const el = document.getElementById(id);
                if(el) { const isPass = el.type === 'password'; el.type = isPass ? 'text' : 'password'; 
                btn.innerHTML = isPass ? '<svg class="icon" viewBox="0 0 24 24"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>' : '<svg class="icon" viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>'; }
            },

            // Profile & Manage Badges
            showProfile: async (uid, name) => {
                if(uid === currentUser.username) return;
                try {
                    const snap = await getDoc(doc(db, "users", uid));
                    if(!snap.exists()) return app.toast("ユーザーが見つかりません");
                    const target = snap.data();
                    const isFriend = currentUser.friends && currentUser.friends.includes(uid);
                    let btnHtml = isFriend ? `<button class="btn btn-success mt-2" onclick="app.startDM('${uid}', '${name.replace(/'/g,"\\'")}')">チャットする</button>` : `<button class="btn btn-primary mt-2" onclick="app.sendRequest('${uid}')">友達申請する</button>`;
                    
                    const myB = currentUser.badges || [];
                    if(app.checkAdmSess() || myB.includes('developer') || myB.includes('staff')) {
                        btnHtml += `<button class="btn btn-warning mt-2" onclick="app.manageBadges('${uid}')">バッジを管理する</button>`;
                    }
                    app.mdl("プロフィール", `<div style="text-align:center"><div style="font-size:3rem; margin-bottom:10px;"><svg class="icon icon-xl" viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg></div><h3>${target.name}</h3><div class="mb-2">${app.getBadgesHtml(target.badges)}</div><p class="text-sub text-xs mb-4">ID: ${uid}</p>${btnHtml}</div>`);
                } catch(e) {}
            },
            manageBadges: async (targetUid) => {
                const s = await getDoc(doc(db, "users", targetUid));
                if(!s.exists()) return;
                const t = s.data(); const b = t.badges || [];
                let html = `<div class="flex flex-col gap-3 mb-4">
                    <label><input type="checkbox" id="mb-dev" ${b.includes('developer')?'checked':''}> 開発者</label>
                    <label><input type="checkbox" id="mb-staff" ${b.includes('staff')?'checked':''}> 関係者</label>
                    <label><input type="checkbox" id="mb-bug" ${b.includes('bug')?'checked':''}> バグ発見者</label>
                    <label><input type="checkbox" id="mb-vip" ${b.includes('vip')?'checked':''}> VIP</label>
                    <label><input type="checkbox" id="mb-veteran" ${b.includes('veteran')?'checked':''}> 古参</label>
                    <label><input type="checkbox" id="mb-official" ${b.includes('official')?'checked':''}> 公式</label>
                </div>
                <button class="btn btn-warning" onclick="app.saveManagedBadges('${targetUid}')">保存</button>`;
                app.mdl("バッジ管理: " + t.name, html);
            },
            saveManagedBadges: async (targetUid) => {
                const s = await getDoc(doc(db, "users", targetUid));
                if(!s.exists()) return;
                const b = s.data().badges || [];
                const handBadges = ['developer','staff','bug','vip','veteran','official'];
                const newB = b.filter(x => !handBadges.includes(x));
                if(document.getElementById('mb-dev').checked) newB.push('developer');
                if(document.getElementById('mb-staff').checked) newB.push('staff');
                if(document.getElementById('mb-bug').checked) newB.push('bug');
                if(document.getElementById('mb-vip').checked) newB.push('vip');
                if(document.getElementById('mb-veteran').checked) newB.push('veteran');
                if(document.getElementById('mb-official').checked) newB.push('official');
                await updateDoc(doc(db, "users", targetUid), { badges: newB });
                app.toast("更新しました"); app.closeModal(); app.showProfile(targetUid, s.data().name);
            },

            // WebRTC Call
            initPeer: (uid) => {
                if(peer) return;
                try {
                    peer = new Peer(uid);
                    peer.on('call', (c) => {
                        if(callStatus!=='idle'){c.close();return;}
                        incomingCallObj=c; callStatus='incoming';
                        const m=c.metadata||{}; document.getElementById('inc-call-name').innerText=m.name||c.peer; document.getElementById('inc-call-type').innerText=m.video?'ビデオ':'音声';
                        app.go('scr-call'); document.getElementById('call-ui-incoming').classList.remove('hidden'); document.getElementById('call-ui-calling').classList.add('hidden'); document.getElementById('call-ui-connected').classList.add('hidden');
                        c.on('close',()=>app.endCall()); c.on('error',()=>app.endCall());
                    });
                    peer.on('error',e=>{ if(e.type==='unavailable-id') app.toast("通話ID重複");});
                } catch(e){}
            },
            startCall: async (videoEnabled) => {
                if(callStatus !== 'idle') return app.toast("通話中です");
                if(!currentRoomId) return;
                const targetUid = currentRoomId.split('_').find(m => m !== currentUser.username);
                if(!targetUid) return;
                callStatus = 'calling'; app.go('scr-call');
                document.getElementById('call-ui-calling').classList.remove('hidden'); document.getElementById('call-ui-incoming').classList.add('hidden'); document.getElementById('call-ui-connected').classList.add('hidden');
                document.getElementById('call-name').innerText = document.getElementById('dm-talk-name').innerText;
                document.getElementById('remote-video').srcObject = null; document.getElementById('local-video').srcObject = null;
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: videoEnabled });
                    document.getElementById('local-video').srcObject = localStream; document.getElementById('local-video').muted = true;
                    if(videoEnabled) document.getElementById('local-video').classList.add('active');
                    if(!peer) app.initPeer(currentUser.username);
                    const call = peer.call(targetUid, localStream, { metadata: { name: currentUser.name, video: videoEnabled } });
                    currentCall = call;
                    call.on('stream', (remote) => {
                        remoteStream = remote; document.getElementById('remote-video').srcObject = remote; callStatus = 'connected';
                        document.getElementById('call-ui-calling').classList.add('hidden'); document.getElementById('call-ui-connected').classList.remove('hidden');
                        document.getElementById('remote-video').play().catch(e=>{});
                    });
                    call.on('close', () => app.endCall()); call.on('error', () => app.endCall());
                } catch(e) { app.toast("エラー"); app.endCall(); }
            },
            answerCall: async () => {
                if(!incomingCallObj) return;
                try {
                    const videoEnabled = incomingCallObj.metadata ? incomingCallObj.metadata.video : false;
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: videoEnabled });
                    document.getElementById('local-video').srcObject = localStream; document.getElementById('local-video').muted = true;
                    if(videoEnabled) document.getElementById('local-video').classList.add('active');
                    incomingCallObj.answer(localStream); currentCall = incomingCallObj; callStatus = 'connected';
                    document.getElementById('call-ui-incoming').classList.add('hidden'); document.getElementById('call-ui-connected').classList.remove('hidden');
                    currentCall.on('stream', (remote) => {
                        remoteStream = remote; document.getElementById('remote-video').srcObject = remote;
                        document.getElementById('remote-video').play().catch(e=>{});
                    });
                    currentCall.on('close', () => app.endCall()); currentCall.on('error', () => app.endCall());
                } catch(e) { app.endCall(); }
            },
            endCall: () => {
                if(currentCall) currentCall.close(); if(incomingCallObj) incomingCallObj.close();
                if(localStream) localStream.getTracks().forEach(t => t.stop());
                currentCall = null; incomingCallObj = null; localStream = null; remoteStream = null; callStatus = 'idle';
                if(currentRoomId) app.go('scr-dm-talk'); else app.tab('home');
            },
            toggleMic: () => { if(localStream) { const t = localStream.getAudioTracks()[0]; if(t) { t.enabled = !t.enabled; document.getElementById('btn-mic-toggle').classList.toggle('active', t.enabled); } } },
            toggleVideo: async () => { app.toast("ビデオ切替"); },

            // Friends & DM (Inline Request)
            searchUserForFriendInline: async () => {
                const tid = document.getElementById('inline-friend-id').value.trim();
                const resDiv = document.getElementById('inline-friend-result');
                if(!tid) return;
                if(tid === currentUser.username) return resDiv.innerHTML="<span class='text-warning text-xs'>自分自身です</span>";
                resDiv.innerHTML = "";
                try {
                    const snap = await getDoc(doc(db, "users", tid));
                    if(!snap.exists()) return resDiv.innerHTML="<span class='text-danger text-xs'>見つかりません</span>";
                    const t = snap.data();
                    resDiv.innerHTML = `<div class="p-3 border border-[var(--primary)] rounded mt-2">
                        <div class="font-bold">${t.name} ${app.getBadgesHtml(t.badges)}</div><div class="text-xs text-sub mb-2">ID: ${tid}</div>
                        <button class="btn btn-success btn-sm w-full" onclick="app.sendRequest('${tid}')">申請を送る</button></div>`;
                } catch(e) { resDiv.innerHTML="エラー"; }
            },
            sendRequest: async (targetId) => {
                if(targetId === currentUser.username) return;
                try {
                    const snap = await getDoc(doc(db, "users", targetId));
                    if(!snap.exists()) return app.toast("見つかりません");
                    const exist = await getDocs(query(collection(db, "requests"), where("from", "==", currentUser.username), where("to", "==", targetId)));
                    if(!exist.empty) return app.toast("申請済みです");
                    if(currentUser.friends && currentUser.friends.includes(targetId)) return app.toast("既に友達です");
                    await addDoc(collection(db, "requests"), { from: currentUser.username, fromName: currentUser.name, to: targetId, toName: snap.data().name, status: 'pending', createdAt: serverTimestamp() });
                    app.toast("申請を送りました");
                } catch(e) {}
            },
            subRequests: (uid) => {
                listeners.push(onSnapshot(query(collection(db, "requests"), where("to", "==", uid)), s => {
                    const list = document.getElementById('requests-list'); list.innerHTML = "";
                    s.forEach(d => {
                        const r = d.data();
                        list.innerHTML += `<div class="flex justify-between items-center mb-2 pb-2 border-b border-[var(--border)]"><div><div class="font-bold text-sm">${r.fromName}</div><div class="text-xs text-sub">ID: ${r.from}</div></div><div class="flex gap-2"><button class="btn btn-sm btn-primary" onclick="app.acceptRequest('${d.id}', '${r.from}')">承認</button><button class="btn btn-sm btn-danger" onclick="app.rejectRequest('${d.id}')">拒否</button></div></div>`;
                    });
                }));
                listeners.push(onSnapshot(query(collection(db, "requests"), where("from", "==", uid)), s => {
                    const list = document.getElementById('outgoing-list'); list.innerHTML = "";
                    s.forEach(d => {
                        list.innerHTML += `<div class="flex justify-between items-center mb-2"><div class="text-sm">${d.data().toName} へ送信中</div><button class="btn btn-sm btn-danger" onclick="app.rejectRequest('${d.id}')">取消</button></div>`;
                    });
                }));
            },
            acceptRequest: async (reqId, fromUid) => {
                try {
                    await runTransaction(db, async tr => {
                        tr.update(doc(db, "users", currentUser.username), { friends: arrayUnion(fromUid) });
                        tr.update(doc(db, "users", fromUid), { friends: arrayUnion(currentUser.username) });
                        tr.delete(doc(db, "requests", reqId));
                    });
                    app.toast("友達になりました！");
                } catch(e) {}
            },
            rejectRequest: async (reqId) => { await deleteDoc(doc(db, "requests", reqId)); },
            subDMList: (uid) => {
                listeners.push(onSnapshot(doc(db, "users", uid), async s => {
                    if (!s.exists()) return;
                    const friends = s.data().friends || [];
                    const list = document.getElementById('dm-list-box'); list.innerHTML = "";
                    for(const fid of friends) {
                        try {
                            const fSnap = await getDoc(doc(db, "users", fid));
                            if(fSnap.exists()) {
                                const fData = fSnap.data();
                                list.innerHTML += `<div class="dm-item" onclick="app.startDM('${fid}', '${fData.name.replace(/'/g,"\\'")}')"><div class="dm-icon">${fData.name.charAt(0)}</div><div><div class="font-bold text-sm">${fData.name} ${app.getBadgesHtml(fData.badges)}</div><div class="text-xs text-sub">ID: ${fid}</div></div></div>`;
                            }
                        } catch(e) {}
                    }
                }));
            },
            startDM: async (targetUid, targetName) => {
                app.closeModal(); 
                const members = [currentUser.username, targetUid].sort(), roomId = members.join("_"), ref = doc(db, "rooms", roomId);
                const snap = await getDoc(ref);
                if(!snap.exists()) await setDoc(ref, { members: members, names: { [currentUser.username]: currentUser.name, [targetUid]: targetName }, updatedAt: serverTimestamp() });
                currentRoomId = roomId; document.getElementById('dm-talk-name').innerText = targetName; document.getElementById('scr-dm-talk').classList.add('active');
                if(dmUnsub) dmUnsub();
                dmUnsub = onSnapshot(query(collection(db, "rooms", roomId, "messages"), limit(50)), s => {
                    const b = document.getElementById('dm-talk-box'); b.innerHTML = "";
                    let msgs = []; s.forEach(d => msgs.push({id:d.id, ...d.data()})); msgs.sort((a,b)=>(a.createdAt?.seconds||0) - (b.createdAt?.seconds||0));
                    msgs.forEach(m => b.innerHTML += app.buildMsgHTML(m, true));
                    setTimeout(()=>b.scrollTop = 99999, 100);
                });
            },
            closeDM: () => { document.getElementById('scr-dm-talk').classList.remove('active'); if(dmUnsub) dmUnsub(); currentRoomId = null; app.cancelReply('dm'); },
            sendDM: async (stampUrl = null) => {
                const i = document.getElementById('dm-in'), t = i.value.trim(); const imgPayload = stampUrl || dmImg;
                if((!t && !imgPayload) || !currentRoomId) return;
                const payload = { text: t, img: imgPayload, username: currentUser.username, sender: currentUser.name, createdAt: serverTimestamp() };
                if(replyTarget.dm) { payload.replyTo = replyTarget.dm; }
                await addDoc(collection(db, "rooms", currentRoomId, "messages"), payload);
                i.value = ""; app.clearDMImg(); app.cancelReply('dm');
            },

            // Chat All (with Anti-Abuse) - FIXED
            subChat: () => {
                if(listeners.chat) return;
                listeners.chat = onSnapshot(query(collection(db,"chat"), limit(50)), s=>{
                    const b = document.getElementById('chat-box'); b.innerHTML="";
                    let msgs=[]; s.forEach(d=>{ const m=d.data(); m.id=d.id; appCache.chat[d.id]=m; msgs.push(m); });
                    msgs.sort((a,b)=>(a.createdAt?.seconds||0) - (b.createdAt?.seconds||0));
                    msgs.forEach(m => b.innerHTML += app.buildMsgHTML(m, false));
                    if(!document.getElementById('tab-chat').classList.contains('hidden')) setTimeout(()=>b.scrollTop=99999, 100);
                });
            },
            sendChat: async (stampUrl = null) => {
                if(currentUser.isMuted) return app.toast('チャットが制限されています');
                const now = Date.now();
                if(now - app.lastChatTime < 1000) return app.toast('送信が早すぎます');
                
                const i=document.getElementById('chat-in'), t=i.value.trim(); const imgPayload = stampUrl || chatImg;
                if(!t && !imgPayload) return;
                
                // Simple NG Word Check
                const ngWords = ['死ね','殺す','馬鹿','アホ','カス','ゴミ','fuck','shit'];
                if(ngWords.some(w => t.includes(w))) return app.toast('不適切な言葉が含まれています');

                app.lastChatTime = now;
                const payload = { text:t, img:imgPayload, username:currentUser.username, sender:currentUser.name, createdAt:serverTimestamp() };
                if(replyTarget.all) { payload.replyTo = replyTarget.all; }
                await addDoc(collection(db,"chat"), payload);
                i.value=""; app.clearChatImg(); app.cancelReply('all');
            },
            buildMsgHTML: (m, isDm = false) => {
                const isMe = m.username === currentUser.username;
                const name = m.sender || "Unknown";
                const type = isDm ? 'dm' : 'all';
                let replyHtml = '';
                if(m.replyTo) {
                    const r = m.replyTo;
                    const rText = r.text ? (r.text.length > 20 ? r.text.substring(0,20)+'...' : r.text) : (r.img ? '画像' : '');
                    replyHtml = `<div class="reply-box-in-msg">${r.img ? `<img src="${r.img}">` : ''}<div class="reply-content"><div style="font-size:0.65rem; color:var(--primary)">${r.name}</div><div>${rText}</div></div></div>`;
                }
                // Use Cache-based openMsgAction call to prevent HTML breakage
                const tapAction = `app.openMsgAction('${type}', '${m.id}', '${currentRoomId||''}')`;
                let contentHtml = '';
                if (m.text) contentHtml += `<div>${m.text}</div>`;
                if (m.img) {
                    const isStamp = !m.text && m.img;
                    const imgClick = isStamp ? "" : `onclick="event.stopPropagation(); document.getElementById('img-full').src=this.src;document.getElementById('img-viewer').style.display='flex'"`;
                    contentHtml += `<img src="${m.img}" class="${m.text?'chat-img':'stamp-img chat-img'}" ${imgClick}>`;
                }
                return `<div class="msg-row ${isMe?'mine':'other'}">
                    ${!isMe?`<span class="msg-name" onclick="app.showProfile('${m.username}','${name.replace(/'/g,"\\'")}')">${name}</span>`:''}
                    <div class="msg-bubble" style="${!m.text && m.img ? 'background:transparent; border:none; padding:0;' : ''}" onclick="${tapAction}">${replyHtml}${contentHtml}</div>
                </div>`;
            },
            // ... (Other functions like DM, WebRTC, Stamp Maker remain standard)

            // Pass Reset
            checkSecurityQuestion: async () => {
                const uid = document.getElementById('rst-uid').value.trim();
                if(!uid) return app.toast("IDを入力してください");
                try {
                    const snap = await getDoc(doc(db, "users", uid));
                    if(!snap.exists()) return app.toast("ユーザーが見つかりません");
                    const d = snap.data();
                    if(!d.secretQ) return app.toast("秘密の質問が未設定です");
                    const qText = { pet: "初めて飼ったペットの名前は？", school: "小学校の名前は？", mother: "母親の旧姓は？", food: "好きな食べ物は？" }[d.secretQ] || "秘密の質問";
                    document.getElementById('rst-q-text').innerText = qText;
                    document.getElementById('rst-step-1').classList.add('hidden');
                    document.getElementById('rst-step-2').classList.remove('hidden');
                    app.resetTargetUid = uid;
                } catch(e) { app.toast("エラー"); }
            },
            doResetPass: async () => {
                const ans = document.getElementById('rst-ans').value.trim();
                const newPass = document.getElementById('rst-new-pass').value.trim();
                if(!ans || !newPass) return app.toast("全て入力してください");
                try {
                    const snap = await getDoc(doc(db, "users", app.resetTargetUid));
                    if(snap.data().secretA === ans) {
                        await updateDoc(doc(db, "users", app.resetTargetUid), { password: newPass });
                        app.toast("パスワードを変更しました"); app.go('scr-login');
                    } else app.toast("答えが違います");
                } catch(e) {}
            },
            togglePass: (id, btn) => {
                const el = document.getElementById(id);
                if(el) { const isPass = el.type === 'password'; el.type = isPass ? 'text' : 'password'; 
                btn.innerHTML = isPass ? '<svg class="icon" viewBox="0 0 24 24"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>' : '<svg class="icon" viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>'; }
            },

            // Profile & Manage Badges
            showProfile: async (uid, name) => {
                if(uid === currentUser.username) return;
                try {
                    const snap = await getDoc(doc(db, "users", uid));
                    if(!snap.exists()) return app.toast("ユーザーが見つかりません");
                    const target = snap.data();
                    const isFriend = currentUser.friends && currentUser.friends.includes(uid);
                    let btnHtml = isFriend ? `<button class="btn btn-success mt-2" onclick="app.startDM('${uid}', '${name.replace(/'/g,"\\'")}')">チャットする</button>` : `<button class="btn btn-primary mt-2" onclick="app.sendRequest('${uid}')">友達申請する</button>`;
                    
                    const myB = currentUser.badges || [];
                    if(app.checkAdmSess() || myB.includes('developer') || myB.includes('staff')) {
                        btnHtml += `<button class="btn btn-warning mt-2" onclick="app.manageBadges('${uid}')">バッジを管理する</button>`;
                    }
                    app.mdl("プロフィール", `<div style="text-align:center"><div style="font-size:3rem; margin-bottom:10px;"><svg class="icon icon-xl" viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg></div><h3>${target.name}</h3><div class="mb-2">${app.getBadgesHtml(target.badges)}</div><p class="text-sub text-xs mb-4">ID: ${uid}</p>${btnHtml}</div>`);
                } catch(e) {}
            },
            manageBadges: async (targetUid) => {
                const s = await getDoc(doc(db, "users", targetUid));
                if(!s.exists()) return;
                const t = s.data(); const b = t.badges || [];
                let html = `<div class="flex flex-col gap-3 mb-4">
                    <label><input type="checkbox" id="mb-dev" ${b.includes('developer')?'checked':''}> 開発者</label>
                    <label><input type="checkbox" id="mb-staff" ${b.includes('staff')?'checked':''}> 関係者</label>
                    <label><input type="checkbox" id="mb-bug" ${b.includes('bug')?'checked':''}> バグ発見者</label>
                    <label><input type="checkbox" id="mb-vip" ${b.includes('vip')?'checked':''}> VIP</label>
                    <label><input type="checkbox" id="mb-veteran" ${b.includes('veteran')?'checked':''}> 古参</label>
                    <label><input type="checkbox" id="mb-official" ${b.includes('official')?'checked':''}> 公式</label>
                </div>
                <button class="btn btn-warning" onclick="app.saveManagedBadges('${targetUid}')">保存</button>`;
                app.mdl("バッジ管理: " + t.name, html);
            },
            saveManagedBadges: async (targetUid) => {
                const s = await getDoc(doc(db, "users", targetUid));
                if(!s.exists()) return;
                const b = s.data().badges || [];
                const handBadges = ['developer','staff','bug','vip','veteran','official'];
                const newB = b.filter(x => !handBadges.includes(x));
                if(document.getElementById('mb-dev').checked) newB.push('developer');
                if(document.getElementById('mb-staff').checked) newB.push('staff');
                if(document.getElementById('mb-bug').checked) newB.push('bug');
                if(document.getElementById('mb-vip').checked) newB.push('vip');
                if(document.getElementById('mb-veteran').checked) newB.push('veteran');
                if(document.getElementById('mb-official').checked) newB.push('official');
                await updateDoc(doc(db, "users", targetUid), { badges: newB });
                app.toast("更新しました"); app.closeModal(); app.showProfile(targetUid, s.data().name);
            },

            // WebRTC Call
            initPeer: (uid) => {
                if(peer) return;
                try {
                    peer = new Peer(uid);
                    peer.on('call', (c) => {
                        if(callStatus!=='idle'){c.close();return;}
                        incomingCallObj=c; callStatus='incoming';
                        const m=c.metadata||{}; document.getElementById('inc-call-name').innerText=m.name||c.peer; document.getElementById('inc-call-type').innerText=m.video?'ビデオ':'音声';
                        app.go('scr-call'); document.getElementById('call-ui-incoming').classList.remove('hidden'); document.getElementById('call-ui-calling').classList.add('hidden'); document.getElementById('call-ui-connected').classList.add('hidden');
                        c.on('close',()=>app.endCall()); c.on('error',()=>app.endCall());
                    });
                    peer.on('error',e=>{ if(e.type==='unavailable-id') app.toast("通話ID重複");});
                } catch(e){}
            },
            startCall: async (videoEnabled) => {
                if(callStatus !== 'idle') return app.toast("通話中です");
                if(!currentRoomId) return;
                const targetUid = currentRoomId.split('_').find(m => m !== currentUser.username);
                if(!targetUid) return;
                callStatus = 'calling'; app.go('scr-call');
                document.getElementById('call-ui-calling').classList.remove('hidden'); document.getElementById('call-ui-incoming').classList.add('hidden'); document.getElementById('call-ui-connected').classList.add('hidden');
                document.getElementById('call-name').innerText = document.getElementById('dm-talk-name').innerText;
                document.getElementById('remote-video').srcObject = null; document.getElementById('local-video').srcObject = null;
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: videoEnabled });
                    document.getElementById('local-video').srcObject = localStream; document.getElementById('local-video').muted = true;
                    if(videoEnabled) document.getElementById('local-video').classList.add('active');
                    if(!peer) app.initPeer(currentUser.username);
                    const call = peer.call(targetUid, localStream, { metadata: { name: currentUser.name, video: videoEnabled } });
                    currentCall = call;
                    call.on('stream', (remote) => {
                        remoteStream = remote; document.getElementById('remote-video').srcObject = remote; callStatus = 'connected';
                        document.getElementById('call-ui-calling').classList.add('hidden'); document.getElementById('call-ui-connected').classList.remove('hidden');
                        document.getElementById('remote-video').play().catch(e=>{});
                    });
                    call.on('close', () => app.endCall()); call.on('error', () => app.endCall());
                } catch(e) { app.toast("エラー"); app.endCall(); }
            },
            answerCall: async () => {
                if(!incomingCallObj) return;
                try {
                    const videoEnabled = incomingCallObj.metadata ? incomingCallObj.metadata.video : false;
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: videoEnabled });
                    document.getElementById('local-video').srcObject = localStream; document.getElementById('local-video').muted = true;
                    if(videoEnabled) document.getElementById('local-video').classList.add('active');
                    incomingCallObj.answer(localStream); currentCall = incomingCallObj; callStatus = 'connected';
                    document.getElementById('call-ui-incoming').classList.add('hidden'); document.getElementById('call-ui-connected').classList.remove('hidden');
                    currentCall.on('stream', (remote) => {
                        remoteStream = remote; document.getElementById('remote-video').srcObject = remote;
                        document.getElementById('remote-video').play().catch(e=>{});
                    });
                    currentCall.on('close', () => app.endCall()); currentCall.on('error', () => app.endCall());
                } catch(e) { app.endCall(); }
            },
            endCall: () => {
                if(currentCall) currentCall.close(); if(incomingCallObj) incomingCallObj.close();
                if(localStream) localStream.getTracks().forEach(t => t.stop());
                currentCall = null; incomingCallObj = null; localStream = null; remoteStream = null; callStatus = 'idle';
                if(currentRoomId) app.go('scr-dm-talk'); else app.tab('home');
            },
            toggleMic: () => { if(localStream) { const t = localStream.getAudioTracks()[0]; if(t) { t.enabled = !t.enabled; document.getElementById('btn-mic-toggle').classList.toggle('active', t.enabled); } } },
            toggleVideo: async () => { app.toast("ビデオ切替"); },

            // Friends & DM (Inline Request)
            searchUserForFriendInline: async () => {
                const tid = document.getElementById('inline-friend-id').value.trim();
                const resDiv = document.getElementById('inline-friend-result');
                if(!tid) return;
                if(tid === currentUser.username) return resDiv.innerHTML="<span class='text-warning text-xs'>自分自身です</span>";
                resDiv.innerHTML = "";
                try {
                    const snap = await getDoc(doc(db, "users", tid));
                    if(!snap.exists()) return resDiv.innerHTML="<span class='text-danger text-xs'>見つかりません</span>";
                    const t = snap.data();
                    resDiv.innerHTML = `<div class="p-3 border border-[var(--primary)] rounded mt-2">
                        <div class="font-bold">${t.name} ${app.getBadgesHtml(t.badges)}</div><div class="text-xs text-sub mb-2">ID: ${tid}</div>
                        <button class="btn btn-success btn-sm w-full" onclick="app.sendRequest('${tid}')">申請を送る</button></div>`;
                } catch(e) { resDiv.innerHTML="エラー"; }
            },
            sendRequest: async (targetId) => {
                if(targetId === currentUser.username) return;
                try {
                    const snap = await getDoc(doc(db, "users", targetId));
                    if(!snap.exists()) return app.toast("見つかりません");
                    const exist = await getDocs(query(collection(db, "requests"), where("from", "==", currentUser.username), where("to", "==", targetId)));
                    if(!exist.empty) return app.toast("申請済みです");
                    if(currentUser.friends && currentUser.friends.includes(targetId)) return app.toast("既に友達です");
                    await addDoc(collection(db, "requests"), { from: currentUser.username, fromName: currentUser.name, to: targetId, toName: snap.data().name, status: 'pending', createdAt: serverTimestamp() });
                    app.toast("申請を送りました");
                } catch(e) {}
            },
            subRequests: (uid) => {
                listeners.push(onSnapshot(query(collection(db, "requests"), where("to", "==", uid)), s => {
                    const list = document.getElementById('requests-list'); list.innerHTML = "";
                    s.forEach(d => {
                        const r = d.data();
                        list.innerHTML += `<div class="flex justify-between items-center mb-2 pb-2 border-b border-[var(--border)]"><div><div class="font-bold text-sm">${r.fromName}</div><div class="text-xs text-sub">ID: ${r.from}</div></div><div class="flex gap-2"><button class="btn btn-sm btn-primary" onclick="app.acceptRequest('${d.id}', '${r.from}')">承認</button><button class="btn btn-sm btn-danger" onclick="app.rejectRequest('${d.id}')">拒否</button></div></div>`;
                    });
                }));
                listeners.push(onSnapshot(query(collection(db, "requests"), where("from", "==", uid)), s => {
                    const list = document.getElementById('outgoing-list'); list.innerHTML = "";
                    s.forEach(d => {
                        list.innerHTML += `<div class="flex justify-between items-center mb-2"><div class="text-sm">${d.data().toName} へ送信中</div><button class="btn btn-sm btn-danger" onclick="app.rejectRequest('${d.id}')">取消</button></div>`;
                    });
                }));
            },
            acceptRequest: async (reqId, fromUid) => {
                try {
                    await runTransaction(db, async tr => {
                        tr.update(doc(db, "users", currentUser.username), { friends: arrayUnion(fromUid) });
                        tr.update(doc(db, "users", fromUid), { friends: arrayUnion(currentUser.username) });
                        tr.delete(doc(db, "requests", reqId));
                    });
                    app.toast("友達になりました！");
                } catch(e) {}
            },
            rejectRequest: async (reqId) => { await deleteDoc(doc(db, "requests", reqId)); },
            subDMList: (uid) => {
                listeners.push(onSnapshot(doc(db, "users", uid), async s => {
                    if (!s.exists()) return;
                    const friends = s.data().friends || [];
                    const list = document.getElementById('dm-list-box'); list.innerHTML = "";
                    for(const fid of friends) {
                        try {
                            const fSnap = await getDoc(doc(db, "users", fid));
                            if(fSnap.exists()) {
                                const fData = fSnap.data();
                                list.innerHTML += `<div class="dm-item" onclick="app.startDM('${fid}', '${fData.name.replace(/'/g,"\\'")}')"><div class="dm-icon">${fData.name.charAt(0)}</div><div><div class="font-bold text-sm">${fData.name} ${app.getBadgesHtml(fData.badges)}</div><div class="text-xs text-sub">ID: ${fid}</div></div></div>`;
                            }
                        } catch(e) {}
                    }
                }));
            },
            startDM: async (targetUid, targetName) => {
                app.closeModal(); 
                const members = [currentUser.username, targetUid].sort(), roomId = members.join("_"), ref = doc(db, "rooms", roomId);
                const snap = await getDoc(ref);
                if(!snap.exists()) await setDoc(ref, { members: members, names: { [currentUser.username]: currentUser.name, [targetUid]: targetName }, updatedAt: serverTimestamp() });
                currentRoomId = roomId; document.getElementById('dm-talk-name').innerText = targetName; document.getElementById('scr-dm-talk').classList.add('active');
                if(dmUnsub) dmUnsub();
                dmUnsub = onSnapshot(query(collection(db, "rooms", roomId, "messages"), limit(50)), s => {
                    const b = document.getElementById('dm-talk-box'); b.innerHTML = "";
                    let msgs = []; s.forEach(d => msgs.push({id:d.id, ...d.data()})); msgs.sort((a,b)=>(a.createdAt?.seconds||0) - (b.createdAt?.seconds||0));
                    msgs.forEach(m => b.innerHTML += app.buildMsgHTML(m, true));
                    setTimeout(()=>b.scrollTop = 99999, 100);
                });
            },
            closeDM: () => { document.getElementById('scr-dm-talk').classList.remove('active'); if(dmUnsub) dmUnsub(); currentRoomId = null; app.cancelReply('dm'); },
            sendDM: async (stampUrl = null) => {
                const i = document.getElementById('dm-in'), t = i.value.trim(); const imgPayload = stampUrl || dmImg;
                if((!t && !imgPayload) || !currentRoomId) return;
                const payload = { text: t, img: imgPayload, username: currentUser.username, sender: currentUser.name, createdAt: serverTimestamp() };
                if(replyTarget.dm) { payload.replyTo = replyTarget.dm; }
                await addDoc(collection(db, "rooms", currentRoomId, "messages"), payload);
                i.value = ""; app.clearDMImg(); app.cancelReply('dm');
            },

            // Chat All (with Anti-Abuse) - FIXED
            subChat: () => {
                if(listeners.chat) return;
                listeners.chat = onSnapshot(query(collection(db,"chat"), limit(50)), s=>{
                    const b = document.getElementById('chat-box'); b.innerHTML="";
                    let msgs=[]; s.forEach(d=>{ const m=d.data(); m.id=d.id; appCache.chat[d.id]=m; msgs.push(m); });
                    msgs.sort((a,b)=>(a.createdAt?.seconds||0) - (b.createdAt?.seconds||0));
                    msgs.forEach(m => b.innerHTML += app.buildMsgHTML(m, false));
                    if(!document.getElementById('tab-chat').classList.contains('hidden')) setTimeout(()=>b.scrollTop=99999, 100);
                });
            },
            sendChat: async (stampUrl = null) => {
                if(currentUser.isMuted) return app.toast('チャットが制限されています');
                const now = Date.now();
                if(now - app.lastChatTime < 1000) return app.toast('送信が早すぎます');
                
                const i=document.getElementById('chat-in'), t=i.value.trim(); const imgPayload = stampUrl || chatImg;
                if(!t && !imgPayload) return;
                
                // Simple NG Word Check
                const ngWords = ['死ね','殺す','馬鹿','アホ','カス','ゴミ','fuck','shit'];
                if(ngWords.some(w => t.includes(w))) return app.toast('不適切な言葉が含まれています');

                app.lastChatTime = now;
                const payload = { text:t, img:imgPayload, username:currentUser.username, sender:currentUser.name, createdAt:serverTimestamp() };
                if(replyTarget.all) { payload.replyTo = replyTarget.all; }
                await addDoc(collection(db,"chat"), payload);
                i.value=""; app.clearChatImg(); app.cancelReply('all');
            },
            buildMsgHTML: (m, isDm = false) => {
                const isMe = m.username === currentUser.username;
                const name = m.sender || "Unknown";
                const type = isDm ? 'dm' : 'all';
                let replyHtml = '';
                if(m.replyTo) {
                    const r = m.replyTo;
                    const rText = r.text ? (r.text.length > 20 ? r.text.substring(0,20)+'...' : r.text) : (r.img ? '画像' : '');
                    replyHtml = `<div class="reply-box-in-msg">${r.img ? `<img src="${r.img}">` : ''}<div class="reply-content"><div style="font-size:0.65rem; color:var(--primary)">${r.name}</div><div>${rText}</div></div></div>`;
                }
                // Use Cache-based openMsgAction call to prevent HTML breakage
                const tapAction = `app.openMsgAction('${type}', '${m.id}', '${currentRoomId||''}')`;
                let contentHtml = '';
                if (m.text) contentHtml += `<div>${m.text}</div>`;
                if (m.img) {
                    const isStamp = !m.text && m.img;
                    const imgClick = isStamp ? "" : `onclick="event.stopPropagation(); document.getElementById('img-full').src=this.src;document.getElementById('img-viewer').style.display='flex'"`;
                    contentHtml += `<img src="${m.img}" class="${m.text?'chat-img':'stamp-img chat-img'}" ${imgClick}>`;
                }
                return `<div class="msg-row ${isMe?'mine':'other'}">
                    ${!isMe?`<span class="msg-name" onclick="app.showProfile('${m.username}','${name.replace(/'/g,"\\'")}')">${name}</span>`:''}
                    <div class="msg-bubble" style="${!m.text && m.img ? 'background:transparent; border:none; padding:0;' : ''}" onclick="${tapAction}">${replyHtml}${contentHtml}</div>
                </div>`;
            },
            // ... (Other functions like DM, WebRTC, Stamp Maker remain standard)

            // Pass Reset
            checkSecurityQuestion: async () => {
                const uid = document.getElementById('rst-uid').value.trim();
                if(!uid) return app.toast("IDを入力してください");
                try {
                    const snap = await getDoc(doc(db, "users", uid));
                    if(!snap.exists()) return app.toast("ユーザーが見つかりません");
                    const d = snap.data();
                    if(!d.secretQ) return app.toast("秘密の質問が未設定です");
                    const qText = { pet: "初めて飼ったペットの名前は？", school: "小学校の名前は？", mother: "母親の旧姓は？", food: "好きな食べ物は？" }[d.secretQ] || "秘密の質問";
                    document.getElementById('rst-q-text').innerText = qText;
                    document.getElementById('rst-step-1').classList.add('hidden');
                    document.getElementById('rst-step-2').classList.remove('hidden');
                    app.resetTargetUid = uid;
                } catch(e) { app.toast("エラー"); }
            },
            doResetPass: async () => {
                const ans = document.getElementById('rst-ans').value.trim();
                const newPass = document.getElementById('rst-new-pass').value.trim();
                if(!ans || !newPass) return app.toast("全て入力してください");
                try {
                    const snap = await getDoc(doc(db, "users", app.resetTargetUid));
                    if(snap.data().secretA === ans) {
                        await updateDoc(doc(db, "users", app.resetTargetUid), { password: newPass });
                        app.toast("パスワードを変更しました"); app.go('scr-login');
                    } else app.toast("答えが違います");
                } catch(e) {}
            },
            togglePass: (id, btn) => {
                const el = document.getElementById(id);
                if(el) { const isPass = el.type === 'password'; el.type = isPass ? 'text' : 'password'; 
                btn.innerHTML = isPass ? '<svg class="icon" viewBox="0 0 24 24"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>' : '<svg class="icon" viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>'; }
            },

            // Profile & Manage Badges
            showProfile: async (uid, name) => {
                if(uid === currentUser.username) return;
                try {
                    const snap = await getDoc(doc(db, "users", uid));
                    if(!snap.exists()) return app.toast("ユーザーが見つかりません");
                    const target = snap.data();
                    const isFriend = currentUser.friends && currentUser.friends.includes(uid);
                    let btnHtml = isFriend ? `<button class="btn btn-success mt-2" onclick="app.startDM('${uid}', '${name.replace(/'/g,"\\'")}')">チャットする</button>` : `<button class="btn btn-primary mt-2" onclick="app.sendRequest('${uid}')">友達申請する</button>`;
                    
                    const myB = currentUser.badges || [];
                    if(app.checkAdmSess() || myB.includes('developer') || myB.includes('staff')) {
                        btnHtml += `<button class="btn btn-warning mt-2" onclick="app.manageBadges('${uid}')">バッジを管理する</button>`;
                    }
                    app.mdl("プロフィール", `<div style="text-align:center"><div style="font-size:3rem; margin-bottom:10px;"><svg class="icon icon-xl" viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg></div><h3>${target.name}</h3><div class="mb-2">${app.getBadgesHtml(target.badges)}</div><p class="text-sub text-xs mb-4">ID: ${uid}</p>${btnHtml}</div>`);
                } catch(e) {}
            },
            manageBadges: async (targetUid) => {
                const s = await getDoc(doc(db, "users", targetUid));
                if(!s.exists()) return;
                const t = s.data(); const b = t.badges || [];
                let html = `<div class="flex flex-col gap-3 mb-4">
                    <label><input type="checkbox" id="mb-dev" ${b.includes('developer')?'checked':''}> 開発者</label>
                    <label><input type="checkbox" id="mb-staff" ${b.includes('staff')?'checked':''}> 関係者</label>
                    <label><input type="checkbox" id="mb-bug" ${b.includes('bug')?'checked':''}> バグ発見者</label>
                    <label><input type="checkbox" id="mb-vip" ${b.includes('vip')?'checked':''}> VIP</label>
                    <label><input type="checkbox" id="mb-veteran" ${b.includes('veteran')?'checked':''}> 古参</label>
                    <label><input type="checkbox" id="mb-official" ${b.includes('official')?'checked':''}> 公式</label>
                </div>
                <button class="btn btn-warning" onclick="app.saveManagedBadges('${targetUid}')">保存</button>`;
                app.mdl("バッジ管理: " + t.name, html);
            },
            saveManagedBadges: async (targetUid) => {
                const s = await getDoc(doc(db, "users", targetUid));
                if(!s.exists()) return;
                const b = s.data().badges || [];
                const handBadges = ['developer','staff','bug','vip','veteran','official'];
                const newB = b.filter(x => !handBadges.includes(x));
                if(document.getElementById('mb-dev').checked) newB.push('developer');
                if(document.getElementById('mb-staff').checked) newB.push('staff');
                if(document.getElementById('mb-bug').checked) newB.push('bug');
                if(document.getElementById('mb-vip').checked) newB.push('vip');
                if(document.getElementById('mb-veteran').checked) newB.push('veteran');
                if(document.getElementById('mb-official').checked) newB.push('official');
                await updateDoc(doc(db, "users", targetUid), { badges: newB });
                app.toast("更新しました"); app.closeModal(); app.showProfile(targetUid, s.data().name);
            },

            // WebRTC Call
            initPeer: (uid) => {
                if(peer) return;
                try {
                    peer = new Peer(uid);
                    peer.on('call', (c) => {
                        if(callStatus!=='idle'){c.close();return;}
                        incomingCallObj=c; callStatus='incoming';
                        const m=c.metadata||{}; document.getElementById('inc-call-name').innerText=m.name||c.peer; document.getElementById('inc-call-type').innerText=m.video?'ビデオ':'音声';
                        app.go('scr-call'); document.getElementById('call-ui-incoming').classList.remove('hidden'); document.getElementById('call-ui-calling').classList.add('hidden'); document.getElementById('call-ui-connected').classList.add('hidden');
                        c.on('close',()=>app.endCall()); c.on('error',()=>app.endCall());
                    });
                    peer.on('error',e=>{ if(e.type==='unavailable-id') app.toast("通話ID重複");});
                } catch(e){}
            },
            startCall: async (videoEnabled) => {
                if(callStatus !== 'idle') return app.toast("通話中です");
                if(!currentRoomId) return;
                const targetUid = currentRoomId.split('_').find(m => m !== currentUser.username);
                if(!targetUid) return;
                callStatus = 'calling'; app.go('scr-call');
                document.getElementById('call-ui-calling').classList.remove('hidden'); document.getElementById('call-ui-incoming').classList.add('hidden'); document.getElementById('call-ui-connected').classList.add('hidden');
                document.getElementById('call-name').innerText = document.getElementById('dm-talk-name').innerText;
                document.getElementById('remote-video').srcObject = null; document.getElementById('local-video').srcObject = null;
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: videoEnabled });
                    document.getElementById('local-video').srcObject = localStream; document.getElementById('local-video').muted = true;
                    if(videoEnabled) document.getElementById('local-video').classList.add('active');
                    if(!peer) app.initPeer(currentUser.username);
                    const call = peer.call(targetUid, localStream, { metadata: { name: currentUser.name, video: videoEnabled } });
                    currentCall = call;
                    call.on('stream', (remote) => {
                        remoteStream = remote; document.getElementById('remote-video').srcObject = remote; callStatus = 'connected';
                        document.getElementById('call-ui-calling').classList.add('hidden'); document.getElementById('call-ui-connected').classList.remove('hidden');
                        document.getElementById('remote-video').play().catch(e=>{});
                    });
                    call.on('close', () => app.endCall()); call.on('error', () => app.endCall());
                } catch(e) { app.toast("エラー"); app.endCall(); }
            },
            answerCall: async () => {
                if(!incomingCallObj) return;
                try {
                    const videoEnabled = incomingCallObj.metadata ? incomingCallObj.metadata.video : false;
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: videoEnabled });
                    document.getElementById('local-video').srcObject = localStream; document.getElementById('local-video').muted = true;
                    if(videoEnabled) document.getElementById('local-video').classList.add('active');
                    incomingCallObj.answer(localStream); currentCall = incomingCallObj; callStatus = 'connected';
                    document.getElementById('call-ui-incoming').classList.add('hidden'); document.getElementById('call-ui-connected').classList.remove('hidden');
                    currentCall.on('stream', (remote) => {
                        remoteStream = remote; document.getElementById('remote-video').srcObject = remote;
                        document.getElementById('remote-video').play().catch(e=>{});
                    });
                    currentCall.on('close', () => app.endCall()); currentCall.on('error', () => app.endCall());
                } catch(e) { app.endCall(); }
            },
            endCall: () => {
                if(currentCall) currentCall.close(); if(incomingCallObj) incomingCallObj.close();
                if(localStream) localStream.getTracks().forEach(t => t.stop());
                currentCall = null; incomingCallObj = null; localStream = null; remoteStream = null; callStatus = 'idle';
                if(currentRoomId) app.go('scr-dm-talk'); else app.tab('home');
            },
            toggleMic: () => { if(localStream) { const t = localStream.getAudioTracks()[0]; if(t) { t.enabled = !t.enabled; document.getElementById('btn-mic-toggle').classList.toggle('active', t.enabled); } } },
            toggleVideo: async () => { app.toast("ビデオ切替"); },

            // Friends & DM (Inline Request)
            searchUserForFriendInline: async () => {
                const tid = document.getElementById('inline-friend-id').value.trim();
                const resDiv = document.getElementById('inline-friend-result');
                if(!tid) return;
                if(tid === currentUser.username) return resDiv.innerHTML="<span class='text-warning text-xs'>自分自身です</span>";
                resDiv.innerHTML = "";
                try {
                    const snap = await getDoc(doc(db, "users", tid));
                    if(!snap.exists()) return resDiv.innerHTML="<span class='text-danger text-xs'>見つかりません</span>";
                    const t = snap.data();
                    resDiv.innerHTML = `<div class="p-3 border border-[var(--primary)] rounded mt-2">
                        <div class="font-bold">${t.name} ${app.getBadgesHtml(t.badges)}</div><div class="text-xs text-sub mb-2">ID: ${tid}</div>
                        <button class="btn btn-success btn-sm w-full" onclick="app.sendRequest('${tid}')">申請を送る</button></div>`;
                } catch(e) { resDiv.innerHTML="エラー"; }
            },
            sendRequest: async (targetId) => {
                if(targetId === currentUser.username) return;
                try {
                    const snap = await getDoc(doc(db, "users", targetId));
                    if(!snap.exists()) return app.toast("見つかりません");
                    const exist = await getDocs(query(collection(db, "requests"), where("from", "==", currentUser.username), where("to", "==", targetId)));
                    if(!exist.empty) return app.toast("申請済みです");
                    if(currentUser.friends && currentUser.friends.includes(targetId)) return app.toast("既に友達です");
                    await addDoc(collection(db, "requests"), { from: currentUser.username, fromName: currentUser.name, to: targetId, toName: snap.data().name, status: 'pending', createdAt: serverTimestamp() });
                    app.toast("申請を送りました");
                } catch(e) {}
            },
            subRequests: (uid) => {
                listeners.push(onSnapshot(query(collection(db, "requests"), where("to", "==", uid)), s => {
                    const list = document.getElementById('requests-list'); list.innerHTML = "";
                    s.forEach(d => {
                        const r = d.data();
                        list.innerHTML += `<div class="flex justify-between items-center mb-2 pb-2 border-b border-[var(--border)]"><div><div class="font-bold text-sm">${r.fromName}</div><div class="text-xs text-sub">ID: ${r.from}</div></div><div class="flex gap-2"><button class="btn btn-sm btn-primary" onclick="app.acceptRequest('${d.id}', '${r.from}')">承認</button><button class="btn btn-sm btn-danger" onclick="app.rejectRequest('${d.id}')">拒否</button></div></div>`;
                    });
                }));
                listeners.push(onSnapshot(query(collection(db, "requests"), where("from", "==", uid)), s => {
                    const list = document.getElementById('outgoing-list'); list.innerHTML = "";
                    s.forEach(d => {
                        list.innerHTML += `<div class="flex justify-between items-center mb-2"><div class="text-sm">${d.data().toName} へ送信中</div><button class="btn btn-sm btn-danger" onclick="app.rejectRequest('${d.id}')">取消</button></div>`;
                    });
                }));
            },
            acceptRequest: async (reqId, fromUid) => {
                try {
                    await runTransaction(db, async tr => {
                        tr.update(doc(db, "users", currentUser.username), { friends: arrayUnion(fromUid) });
                        tr.update(doc(db, "users", fromUid), { friends: arrayUnion(currentUser.username) });
                        tr.delete(doc(db, "requests", reqId));
                    });
                    app.toast("友達になりました！");
                } catch(e) {}
            },
            rejectRequest: async (reqId) => { await deleteDoc(doc(db, "requests", reqId)); },
            subDMList: (uid) => {
                listeners.push(onSnapshot(doc(db, "users", uid), async s => {
                    if (!s.exists()) return;
                    const friends = s.data().friends || [];
                    const list = document.getElementById('dm-list-box'); list.innerHTML = "";
                    for(const fid of friends) {
                        try {
                            const fSnap = await getDoc(doc(db, "users", fid));
                            if(fSnap.exists()) {
                                const fData = fSnap.data();
                                list.innerHTML += `<div class="dm-item" onclick="app.startDM('${fid}', '${fData.name.replace(/'/g,"\\'")}')"><div class="dm-icon">${fData.name.charAt(0)}</div><div><div class="font-bold text-sm">${fData.name} ${app.getBadgesHtml(fData.badges)}</div><div class="text-xs text-sub">ID: ${fid}</div></div></div>`;
                            }
                        } catch(e) {}
                    }
                }));
            },
            startDM: async (targetUid, targetName) => {
                app.closeModal(); 
                const members = [currentUser.username, targetUid].sort(), roomId = members.join("_"), ref = doc(db, "rooms", roomId);
                const snap = await getDoc(ref);
                if(!snap.exists()) await setDoc(ref, { members: members, names: { [currentUser.username]: currentUser.name, [targetUid]: targetName }, updatedAt: serverTimestamp() });
                currentRoomId = roomId; document.getElementById('dm-talk-name').innerText = targetName; document.getElementById('scr-dm-talk').classList.add('active');
                if(dmUnsub) dmUnsub();
                dmUnsub = onSnapshot(query(collection(db, "rooms", roomId, "messages"), limit(50)), s => {
                    const b = document.getElementById('dm-talk-box'); b.innerHTML = "";
                    let msgs = []; s.forEach(d => msgs.push({id:d.id, ...d.data()})); msgs.sort((a,b)=>(a.createdAt?.seconds||0) - (b.createdAt?.seconds||0));
                    msgs.forEach(m => b.innerHTML += app.buildMsgHTML(m, true));
                    setTimeout(()=>b.scrollTop = 99999, 100);
                });
            },
            closeDM: () => { document.getElementById('scr-dm-talk').classList.remove('active'); if(dmUnsub) dmUnsub(); currentRoomId = null; app.cancelReply('dm'); },
            sendDM: async (stampUrl = null) => {
                const i = document.getElementById('dm-in'), t = i.value.trim(); const imgPayload = stampUrl || dmImg;
                if((!t && !imgPayload) || !currentRoomId) return;
                const payload = { text: t, img: imgPayload, username: currentUser.username, sender: currentUser.name, createdAt: serverTimestamp() };
                if(replyTarget.dm) { payload.replyTo = replyTarget.dm; }
                await addDoc(collection(db, "rooms", currentRoomId, "messages"), payload);
                i.value = ""; app.clearDMImg(); app.cancelReply('dm');
            },

            // Chat All (with Anti-Abuse) - FIXED
            subChat: () => {
                if(listeners.chat) return;
                listeners.chat = onSnapshot(query(collection(db,"chat"), limit(50)), s=>{
                    const b = document.getElementById('chat-box'); b.innerHTML="";
                    let msgs=[]; s.forEach(d=>{ const m=d.data(); m.id=d.id; appCache.chat[d.id]=m; msgs.push(m); });
                    msgs.sort((a,b)=>(a.createdAt?.seconds||0) - (b.createdAt?.seconds||0));
                    msgs.forEach(m => b.innerHTML += app.buildMsgHTML(m, false));
                    if(!document.getElementById('tab-chat').classList.contains('hidden')) setTimeout(()=>b.scrollTop=99999, 100);
                });
            },
            sendChat: async (stampUrl = null) => {
                if(currentUser.isMuted) return app.toast('チャットが制限されています');
                const now = Date.now();
                if(now - app.lastChatTime < 1000) return app.toast('送信が早すぎます');
                
                const i=document.getElementById('chat-in'), t=i.value.trim(); const imgPayload = stampUrl || chatImg;
                if(!t && !imgPayload) return;
                
                // Simple NG Word Check
                const ngWords = ['死ね','殺す','馬鹿','アホ','カス','ゴミ','fuck','shit'];
                if(ngWords.some(w => t.includes(w))) return app.toast('不適切な言葉が含まれています');

                app.lastChatTime = now;
                const payload = { text:t, img:imgPayload, username:currentUser.username, sender:currentUser.name, createdAt:serverTimestamp() };
                if(replyTarget.all) { payload.replyTo = replyTarget.all; }
                await addDoc(collection(db,"chat"), payload);
                i.value=""; app.clearChatImg(); app.cancelReply('all');
            },
            buildMsgHTML: (m, isDm = false) => {
                const isMe = m.username === currentUser.username;
                const name = m.sender || "Unknown";
                const type = isDm ? 'dm' : 'all';
                let replyHtml = '';
                if(m.replyTo) {
                    const r = m.replyTo;
                    const rText = r.text ? (r.text.length > 20 ? r.text.substring(0,20)+'...' : r.text) : (r.img ? '画像' : '');
                    replyHtml = `<div class="reply-box-in-msg">${r.img ? `<img src="${r.img}">` : ''}<div class="reply-content"><div style="font-size:0.65rem; color:var(--primary)">${r.name}</div><div>${rText}</div></div></div>`;
                }
                // Use Cache-based openMsgAction call to prevent HTML breakage
                const tapAction = `app.openMsgAction('${type}', '${m.id}', '${currentRoomId||''}')`;
                let contentHtml = '';
                if (m.text) contentHtml += `<div>${m.text}</div>`;
                if (m.img) {
                    const isStamp = !m.text && m.img;
                    const imgClick = isStamp ? "" : `onclick="event.stopPropagation(); document.getElementById('img-full').src=this.src;document.getElementById('img-viewer').style.display='flex'"`;
                    contentHtml += `<img src="${m.img}" class="${m.text?'chat-img':'stamp-img chat-img'}" ${imgClick}>`;
                }
                return `<div class="msg-row ${isMe?'mine':'other'}">
                    ${!isMe?`<span class="msg-name" onclick="app.showProfile('${m.username}','${name.replace(/'/g,"\\'")}')">${name}</span>`:''}
                    <div class="msg-bubble" style="${!m.text && m.img ? 'background:transparent; border:none; padding:0;' : ''}" onclick="${tapAction}">${replyHtml}${contentHtml}</div>
                </div>`;
            },
            // ... (Other functions like DM, WebRTC, Stamp Maker remain standard)

            // Pass Reset
            checkSecurityQuestion: async () => {
                const uid = document.getElementById('rst-uid').value.trim();
                if(!uid) return app.toast("IDを入力してください");
                try {
                    const snap = await getDoc(doc(db, "users", uid));
                    if(!snap.exists()) return app.toast("ユーザーが見つかりません");
                    const d = snap.data();
                    if(!d.secretQ) return app.toast("秘密の質問が未設定です");
                    const qText = { pet: "初めて飼ったペットの名前は？", school: "小学校の名前は？", mother: "母親の旧姓は？", food: "好きな食べ物は？" }[d.secretQ] || "秘密の質問";
                    document.getElementById('rst-q-text').innerText = qText;
                    document.getElementById('rst-step-1').classList.add('hidden');
                    document.getElementById('rst-step-2').classList.remove('hidden');
                    app.resetTargetUid = uid;
                } catch(e) { app.toast("エラー"); }
            },
            doResetPass: async () => {
                const ans = document.getElementById('rst-ans').value.trim();
                const newPass = document.getElementById('rst-new-pass').value.trim();
                if(!ans || !newPass) return app.toast("全て入力してください");
                try {
                    const snap = await getDoc(doc(db, "users", app.resetTargetUid));
                    if(snap.data().secretA === ans) {
                        await updateDoc(doc(db, "users", app.resetTargetUid), { password: newPass });
                        app.toast("パスワードを変更しました"); app.go('scr-login');
                    } else app.toast("答えが違います");
                } catch(e) {}
            },
            togglePass: (id, btn) => {
                const el = document.getElementById(id);
                if(el) { const isPass = el.type === 'password'; el.type = isPass ? 'text' : 'password'; 
                btn.innerHTML = isPass ? '<svg class="icon" viewBox="0 0 24 24"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>' : '<svg class="icon" viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>'; }
            },

            // Profile & Manage Badges
            showProfile: async (uid, name) => {
                if(uid === currentUser.username) return;
                try {
                    const snap = await getDoc(doc(db, "users", uid));
                    if(!snap.exists()) return app.toast("ユーザーが見つかりません");
                    const target = snap.data();
                    const isFriend = currentUser.friends && currentUser.friends.includes(uid);
                    let btnHtml = isFriend ? `<button class="btn btn-success mt-2" onclick="app.startDM('${uid}', '${name.replace(/'/g,"\\'")}')">チャットする</button>` : `<button class="btn btn-primary mt-2" onclick="app.sendRequest('${uid}')">友達申請する</button>`;
                    
                    const myB = currentUser.badges || [];
                    if(app.checkAdmSess() || myB.includes('developer') || myB.includes('staff')) {
                        btnHtml += `<button class="btn btn-warning mt-2" onclick="app.manageBadges('${uid}')">バッジを管理する</button>`;
                    }
                    app.mdl("プロフィール", `<div style="text-align:center"><div style="font-size:3rem; margin-bottom:10px;"><svg class="icon icon-xl" viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg></div><h3>${target.name}</h3><div class="mb-2">${app.getBadgesHtml(target.badges)}</div><p class="text-sub text-xs mb-4">ID: ${uid}</p>${btnHtml}</div>`);
                } catch(e) {}
            },
            manageBadges: async (targetUid) => {
                const s = await getDoc(doc(db, "users", targetUid));
                if(!s.exists()) return;
                const t = s.data(); const b = t.badges || [];
                let html = `<div class="flex flex-col gap-3 mb-4">
                    <label><input type="checkbox" id="mb-dev" ${b.includes('developer')?'checked':''}> 開発者</label>
                    <label><input type="checkbox" id="mb-staff" ${b.includes('staff')?'checked':''}> 関係者</label>
                    <label><input type="checkbox" id="mb-bug" ${b.includes('bug')?'checked':''}> バグ発見者</label>
                    <label><input type="checkbox" id="mb-vip" ${b.includes('vip')?'checked':''}> VIP</label>
                    <label><input type="checkbox" id="mb-veteran" ${b.includes('veteran')?'checked':''}> 古参</label>
                    <label><input type="checkbox" id="mb-official" ${b.includes('official')?'checked':''}> 公式</label>
                </div>
                <button class="btn btn-warning" onclick="app.saveManagedBadges('${targetUid}')">保存</button>`;
                app.mdl("バッジ管理: " + t.name, html);
            },
            saveManagedBadges: async (targetUid) => {
                const s = await getDoc(doc(db, "users", targetUid));
                if(!s.exists()) return;
                const b = s.data().badges || [];
                const handBadges = ['developer','staff','bug','vip','veteran','official'];
                const newB = b.filter(x => !handBadges.includes(x));
                if(document.getElementById('mb-dev').checked) newB.push('developer');
                if(document.getElementById('mb-staff').checked) newB.push('staff');
                if(document.getElementById('mb-bug').checked) newB.push('bug');
                if(document.getElementById('mb-vip').checked) newB.push('vip');
                if(document.getElementById('mb-veteran').checked) newB.push('veteran');
                if(document.getElementById('mb-official').checked) newB.push('official');
                await updateDoc(doc(db, "users", targetUid), { badges: newB });
                app.toast("更新しました"); app.closeModal(); app.showProfile(targetUid, s.data().name);
            },

            // WebRTC Call
            initPeer: (uid) => {
                if(peer) return;
                try {
                    peer = new Peer(uid);
                    peer.on('call', (c) => {
                        if(callStatus!=='idle'){c.close();return;}
                        incomingCallObj=c; callStatus='incoming';
                        const m=c.metadata||{}; document.getElementById('inc-call-name').innerText=m.name||c.peer; document.getElementById('inc-call-type').innerText=m.video?'ビデオ':'音声';
                        app.go('scr-call'); document.getElementById('call-ui-incoming').classList.remove('hidden'); document.getElementById('call-ui-calling').classList.add('hidden'); document.getElementById('call-ui-connected').classList.add('hidden');
                        c.on('close',()=>app.endCall()); c.on('error',()=>app.endCall());
                    });
                    peer.on('error',e=>{ if(e.type==='unavailable-id') app.toast("通話ID重複");});
                } catch(e){}
            },
            startCall: async (videoEnabled) => {
                if(callStatus !== 'idle') return app.toast("通話中です");
                if(!currentRoomId) return;
                const targetUid = currentRoomId.split('_').find(m => m !== currentUser.username);
                if(!targetUid) return;
                callStatus = 'calling'; app.go('scr-call');
                document.getElementById('call-ui-calling').classList.remove('hidden'); document.getElementById('call-ui-incoming').classList.add('hidden'); document.getElementById('call-ui-connected').classList.add('hidden');
                document.getElementById('call-name').innerText = document.getElementById('dm-talk-name').innerText;
                document.getElementById('remote-video').srcObject = null; document.getElementById('local-video').srcObject = null;
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: videoEnabled });
                    document.getElementById('local-video').srcObject = localStream; document.getElementById('local-video').muted = true;
                    if(videoEnabled) document.getElementById('local-video').classList.add('active');
                    if(!peer) app.initPeer(currentUser.username);
                    const call = peer.call(targetUid, localStream, { metadata: { name: currentUser.name, video: videoEnabled } });
                    currentCall = call;
                    call.on('stream', (remote) => {
                        remoteStream = remote; document.getElementById('remote-video').srcObject = remote; callStatus = 'connected';
                        document.getElementById('call-ui-calling').classList.add('hidden'); document.getElementById('call-ui-connected').classList.remove('hidden');
                        document.getElementById('remote-video').play().catch(e=>{});
                    });
                    call.on('close', () => app.endCall()); call.on('error', () => app.endCall());
                } catch(e) { app.toast("エラー"); app.endCall(); }
            },
            answerCall: async () => {
                if(!incomingCallObj) return;
                try {
                    const videoEnabled = incomingCallObj.metadata ? incomingCallObj.metadata.video : false;
                    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: videoEnabled });
                    document.getElementById('local-video').srcObject = localStream; document.getElementById('local-video').muted = true;
                    if(videoEnabled) document.getElementById('local-video').classList.add('active');
                    incomingCallObj.answer(localStream); currentCall = incomingCallObj; callStatus = 'connected';
                    document.getElementById('call-ui-incoming').classList.add('hidden'); document.getElementById('call-ui-connected').classList.remove('hidden');
                    currentCall.on('stream', (remote) => {
                        remoteStream = remote; document.getElementById('remote-video').srcObject = remote;
                        document.getElementById('remote-video').play().catch(e=>{});
                    });
                    currentCall.on('close', () => app.endCall()); currentCall.on('error', () => app.endCall());
                } catch(e) { app.endCall(); }
            },
            endCall: () => {
                if(currentCall) currentCall.close(); if(incomingCallObj) incomingCallObj.close();
                if(localStream) localStream.getTracks().forEach(t => t.stop());
                currentCall = null; incomingCallObj = null; localStream = null; remoteStream = null; callStatus = 'idle';
                if(currentRoomId) app.go('scr-dm-talk'); else app.tab('home');
            },
            toggleMic: () => { if(localStream) { const t = localStream.getAudioTracks()[0]; if(t) { t.enabled = !t.enabled; document.getElementById('btn-mic-toggle').classList.toggle('active', t.enabled); } } },
            toggleVideo: async () => { app.toast("ビデオ切替"); },

            // Friends & DM (Inline Request)
            searchUserForFriendInline: async () => {
                const tid = document.getElementById('inline-friend-id').value.trim();
                const resDiv = document.getElementById('inline-friend-result');
                if(!tid) return;
                if(tid === currentUser.username) return resDiv.innerHTML="<span class='text-warning text-xs'>自分自身です</span>";
                resDiv.innerHTML = "";
                try {
                    const snap = await getDoc(doc(db, "users", tid));
                    if(!snap.exists()) return resDiv.innerHTML="<span class='text-danger text-xs'>見つかりません</span>";
                    const t = snap.data();
                    resDiv.innerHTML = `<div class="p-3 border border-[var(--primary)] rounded mt-2">
                        <div class="font-bold">${t.name} ${app.getBadgesHtml(t.badges)}</div><div class="text-xs text-sub mb-2">ID: ${tid}</div>
                        <button class="btn btn-success btn-sm w-full" onclick="app.sendRequest('${tid}')">申請を送る</button></div>`;
                } catch(e) { resDiv.innerHTML="エラー"; }
            },
            sendRequest: async (targetId) => {
                if(targetId === currentUser.username) return;
                try {
                    const snap = await getDoc(doc(db, "users", targetId));
                    if(!snap.exists()) return app.toast("見つかりません");
                    const exist = await getDocs(query(collection(db, "requests"), where("from", "==", currentUser.username), where("to", "==", targetId)));
                    if(!exist.empty) return app.toast("申請済みです");
                    if(currentUser.friends && currentUser.friends.includes(targetId)) return app.toast("既に友達です");
                    await addDoc(collection(db, "requests"), { from: currentUser.username, fromName: currentUser.name, to: targetId, toName: snap.data().name, status: 'pending', createdAt: serverTimestamp() });
                    app.toast("申請を送りました");
                } catch(e) {}
            },
            subRequests: (uid) => {
                listeners.push(onSnapshot(query(collection(db, "requests"), where("to", "==", uid)), s => {
                    const list = document.getElementById('requests-list'); list.innerHTML = "";
                    s.forEach(d => {
                        const r = d.data();
                        list.innerHTML += `<div class="flex justify-between items-center mb-2 pb-2 border-b border-[var(--border)]"><div><div class="font-bold text-sm">${r.fromName}</div><div class="text-xs text-sub">ID: ${r.from}</div></div><div class="flex gap-2"><button class="btn btn-sm btn-primary" onclick="app.acceptRequest('${d.id}', '${r.from}')">承認</button><button class="btn btn-sm btn-danger" onclick="app.rejectRequest('${d.id}')">拒否</button></div></div>`;
                    });
                }));
                listeners.push(onSnapshot(query(collection(db, "requests"), where("from", "==", uid)), s => {
                    const list = document.getElementById('outgoing-list'); list.innerHTML = "";
                    s.forEach(d => {
                        list.innerHTML += `<div class="flex justify-between items-center mb-2"><div class="text-sm">${d.data().toName} へ送信中</div><button class="btn btn-sm btn-danger" onclick="app.rejectRequest('${d.id}')">取消</button></div>`;
                    });
                }));
            },
            acceptRequest: async (reqId, fromUid) => {
                try {
                    await runTransaction(db, async tr => {
                        tr.update(doc(db, "users", currentUser.username), { friends: arrayUnion(fromUid) });
                        tr.update(doc(db, "users", fromUid), { friends: arrayUnion(currentUser.username) });
                        tr.delete(doc(db, "requests", reqId));
                    });
                    app.toast("友達になりました！");
                } catch(e) {}
            },
            rejectRequest: async (reqId) => { await deleteDoc(doc(db, "requests", reqId)); },
            subDMList: (uid) => {
                listeners.push(onSnapshot(doc(db, "users", uid), async s => {
                    if (!s.exists()) return;
                    const friends = s.data().friends || [];
                    const list = document.getElementById('dm-list-box'); list.innerHTML = "";
                    for(const fid of friends) {
                        try {
                            const fSnap = await getDoc(doc(db, "users", fid));
                            if(fSnap.exists()) {
                                const fData = fSnap.data();
                                list.innerHTML += `<div class="dm-item" onclick="app.startDM('${fid}', '${fData.name.replace(/'/g,"\\'")}')"><div class="dm-icon">${fData.name.charAt(0)}</div><div><div class="font-bold text-sm">${fData.name} ${app.getBadgesHtml(fData.badges)}</div><div class="text-xs text-sub">ID: ${fid}</div></div></div>`;
                            }
                        } catch(e) {}
                    }
                }));
            },
            startDM: async (targetUid, targetName) => {
                app.closeModal(); 
                const members = [currentUser.username, targetUid].sort(), roomId = members.join("_"), ref = doc(db, "rooms", roomId);
                const snap = await getDoc(ref);
                if(!snap.exists()) await setDoc(ref, { members: members, names: { [currentUser.username]: currentUser.name, [targetUid]: targetName }, updatedAt: serverTimestamp() });
                currentRoomId = roomId; document.getElementById('dm-talk-name').innerText = targetName; document.getElementById('scr-dm-talk').classList.add('active');
                if(dmUnsub) dmUnsub();
                dmUnsub = onSnapshot(query(collection(db, "rooms", roomId, "messages"), limit(50)), s => {
                    const b = document.getElementById('dm-talk-box'); b.innerHTML = "";
                    let msgs = []; s.forEach(d => msgs.push({id:d.id, ...d.data()})); msgs.sort((a,b)=>(a.createdAt?.seconds||0) - (b.createdAt?.seconds||0));
                    msgs.forEach(m => b.innerHTML += app.buildMsgHTML(m, true));
                    setTimeout(()=>b.scrollTop = 99999, 100);
                });
            },
            closeDM: () => { document.getElementById('scr-dm-talk').classList.remove('active'); if(dmUnsub) dmUnsub(); currentRoomId = null; app.cancelReply('dm'); },
            sendDM: async (stampUrl = null) => {
                const i = document.getElementById('dm-in'), t = i.value.trim(); const imgPayload = stampUrl || dmImg;
                if((!t && !imgPayload) || !currentRoomId) return;
                const payload = { text: t, img: imgPayload, username: currentUser.username, sender: currentUser.name, createdAt: serverTimestamp() };
                if(replyTarget.dm) { payload.replyTo = replyTarget.dm; }
                await addDoc(collection(db, "rooms", currentRoomId, "messages"), payload);
                i.value = ""; app.clearDMImg(); app.cancelReply('dm');
            },

            // Chat All (with Anti-Abuse) - FIXED
            subChat: () => {
                if(listeners.chat) return;
                listeners.chat = onSnapshot(query(collection(db,"chat"), limit(50)), s=>{
                    const b = document.getElementById('chat-box'); b.innerHTML="";
                    let msgs=[]; s.forEach(d=>{ const m=d.data(); m.id=d.id; appCache.chat[d.id]=m; msgs.push(m); });
                    msgs.sort((a,b)=>(a.createdAt?.seconds||0) - (b.createdAt?.seconds||0));
                    msgs.forEach(m => b.innerHTML += app.buildMsgHTML(m, false));
                    if(!document.getElementById('tab-chat').classList.contains('hidden')) setTimeout(()=>b.scrollTop=99999, 100);
                });
            },
            sendChat: async (stampUrl = null) => {
                if(currentUser.isMuted) return app.toast('チャットが制限されています');
                const now = Date.now();
                if(now - app.lastChatTime < 1000) return app.toast('送信が早すぎます');
                
                const i=document.getElementById('chat-in'), t=i.value.trim(); const imgPayload = stampUrl || chatImg;
                if(!t && !imgPayload) return;
                
                // Simple NG Word Check
                const ngWords = ['死ね','殺す','馬鹿','アホ','カス','ゴミ','fuck','shit'];
                if(ngWords.some(w => t.includes(w))) return app.toast('不適切な言葉が含まれています');

                app.lastChatTime = now;
                const payload = { text:t, img:imgPayload, username:currentUser.username, sender:currentUser.name, createdAt:serverTimestamp() };
                if(replyTarget.all) { payload.replyTo = replyTarget.all; }
                await addDoc(collection(db,"chat"), payload);
                i.value=""; app.clearChatImg(); app.cancelReply('all');
            },
            buildMsgHTML: (m, isDm = false) => {
                const isMe = m.username === currentUser.username;
                const name = m.sender || "Unknown";
                const type = isDm ? 'dm' : 'all';
                let replyHtml = '';
                if(m.replyTo) {
                    const r = m.replyTo;
                    const rText = r.text ? (r.text.length > 20 ? r.text.substring(0,20)+'...' : r.text) : (r.img ? '画像' : '');
                    replyHtml = `<div class="reply-box-in-msg">${r.img ? `<img src="${r.img}">` : ''}<div class="reply-content"><div style="font-size:0.65rem; color:var(--primary)">${r.name}</div><div>${rText}</div></div></div>`;
                }
                // Use Cache-based openMsgAction call to prevent HTML breakage
                const tapAction = `app.openMsgAction('${type}', '${m.id}', '${currentRoomId||''}')`;
                let contentHtml = '';
                if (m.text) contentHtml += `<div>${m.text}</div>`;
                if (m.img) {
                    const isStamp = !m.text && m.img;
                    const imgClick = isStamp ? "" : `onclick="event.stopPropagation(); document.getElementById('img-full').src=this.src;document.getElementById('img-viewer').style.display='flex'"`;
                    contentHtml += `<img src="${m.img}" class="${m.text?'chat-img':'stamp-img chat-img'}" ${imgClick}>`;
                }
                return `<div class="msg-row ${isMe?'mine':'other'}">
                    ${!isMe?`<span class="msg-name" onclick="app.showProfile('${m.username}','${name.replace(/'/g,"\\'")}')">${name}</span>`:''}
                    <div class="msg-bubble" style="${!m.text && m.img ? 'background:transparent; border:none; padding:0;' : ''}" onclick="${tapAction}">${replyHtml}${contentHtml}</div>
                </div>`;
            },
            // ... (Other functions like DM, WebRTC, Stamp Maker remain standard)

            // Pass Reset
            checkSecurityQuestion: async () => {
                const uid = document.getElementById('rst-uid').value.trim();
                if(!uid) return app.toast("IDを入力してください");
                try {
                    const snap = await getDoc(doc(db, "users", uid));
                    if(!snap.exists()) return app.toast("ユーザーが見つかりません");
                    const d = snap.data();
                    if(!d.secretQ) return app.toast("秘密の質問が未設定です");
                    const qText = { pet: "初めて飼ったペットの名前は？", school: "小学校の名前は？", mother: "母親の旧姓は？", food: "好きな食べ物は？" }[d.secretQ] || "秘密の質問";
                    document.getElementById('rst-q-text').innerText = qText;
                    document.getElementById('rst-step-1').classList.add('hidden');
                    document.getElementById('rst-step-2').classList.remove('hidden');
                    app.resetTargetUid = uid;
                } catch(e) { app.toast("エラー"); }
            },
            doResetPass: async () => {
                const ans = document.getElementById('rst-ans').value.trim();
                const newPass = document.getElementById('rst-new-pass').value.trim();
                if(!ans || !newPass) return app.toast("全て入力してください");
                try {
                    const snap = await getDoc(doc(db, "users", app.resetTargetUid));
                    if(snap.data().secretA === ans) {
                        await updateDoc(doc(db, "users", app.resetTargetUid), { password: newPass });
                        app.toast("パスワードを変更しました"); app.go('scr-login');
                    } else app.toast("答えが違います");
                } catch(e) {}
            },
            togglePass: (id, btn) => {
                const el = document.getElementById(id);
                if(el) { const isPass = el.type === 'password'; el.type = isPass ? 'text' : 'password'; 
                btn.innerHTML = isPass ? '<svg class="icon" viewBox="0 0 24 24"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>' : '<svg class="icon" viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>'; }
            },
            handleFileSelect: (i, type) => {
                if(i.files[0]){
                    const r = new FileReader();
                    r.onload = e => {
                        const img = new Image(); img.onload = () => {
                            const c = document.createElement('canvas'), MAX=800; let w=img.width, h=img.height;
                            if(w>MAX){h*=MAX/w;w=MAX} c.width=w; c.height=h; c.getContext('2d').drawImage(img,0,0,w,h);
                            const d = c.toDataURL('image/jpeg',0.7);
                            if(type==='chat') { chatImg=d; document.getElementById('chat-preview').style.display='flex'; document.getElementById('chat-preview-img').src=d; }
                            else if(type==='dm') { dmImg=d; document.getElementById('dm-preview').style.display='flex'; document.getElementById('dm-preview-img').src=d; }
                            else { newsImg=d; document.getElementById('adm-news-file-status').innerText="選択済"; }
                        }; img.src = e.target.result;
                    }; r.readAsDataURL(i.files[0]);
                }
            },
            clearChatImg: () => { chatImg = null; document.getElementById('chat-file').value = ""; document.getElementById('chat-preview').style.display = 'none'; },
            clearDMImg: () => { dmImg = null; document.getElementById('dm-file').value = ""; document.getElementById('dm-preview').style.display = 'none'; },
            switchChatMode: (mode) => {
                document.getElementById('area-all-chat').style.display = mode==='all'?'flex':'none';
                document.getElementById('area-dm-list').style.display = mode==='dm'?'flex':'none';
                document.getElementById('sw-all').classList.toggle('active', mode==='all');
                document.getElementById('sw-dm').classList.toggle('active', mode==='dm');
            },

            // Stamp Maker & Paid Stamps
            openStampModal: () => { document.getElementById('stamp-modal').style.display = 'flex'; app.switchStampTab('public'); },
            closeStampModal: () => { document.getElementById('stamp-modal').style.display = 'none'; },
            switchStampTab: (tab) => {
                currentStampTab = tab;
                document.querySelectorAll('.stamp-tab').forEach(el => el.classList.remove('active'));
                document.getElementById(`tab-stamp-${tab}`).classList.add('active');
                app.loadStamps();
            },
            loadStamps: async (packId = null) => {
                const list = document.getElementById('stamp-list'); list.innerHTML = "";
                if (packId) {
                    const snap = await getDocs(query(collection(db, "stamps"), where("packId", "==", packId), where("status", "==", "approved")));
                    list.innerHTML = "<div class='col-span-3 btn btn-ghost btn-sm mb-2' onclick='app.loadStamps()'>← 戻る</div>";
                    const rows=[]; snap.forEach(d=>rows.push(d.data())); rows.sort((a,b)=>(a.order||0)-(b.order||0));
                    rows.forEach(d => {
                        const item = document.createElement('div'); item.className = 'stamp-item'; item.innerHTML = `<img src="${d.url}">`;
                        item.onclick = () => { if(currentRoomId) app.sendDM(d.url); else app.sendChat(d.url); app.closeStampModal(); };
                        list.appendChild(item);
                    });
                } else {
                    let q = currentStampTab === 'public' ? query(collection(db, "stampPacks"), where("isPublic", "==", true), where("status", "==", "approved"), limit(50)) : query(collection(db, "stampPacks"), where("ownerUid", "==", currentUser.username), limit(50));
                    const snap = await getDocs(q);
                    const packs=[]; snap.forEach(d=>packs.push({id:d.id, ...d.data()})); packs.sort((a,b)=>(b.createdAt?.seconds||0)-(a.createdAt?.seconds||0));
                    packs.forEach(p => {
                        const item = document.createElement('div'); item.className = 'stamp-item'; item.style.border = '1px solid var(--border)';
                        let badge = p.ownerUid===currentUser.username ? (p.status==='approved'?"":`<div style='position:absolute;bottom:0;width:100%;background:rgba(0,0,0,0.7);font-size:0.6rem;text-align:center'>申請中</div>`) : '';
                        let priceBadge = '';
                        const myPurchases = currentUser.purchasedPacks || [];
                        const needBuy = p.isPaid && p.ownerUid !== currentUser.username && !myPurchases.includes(p.id);
                        if(needBuy) priceBadge = `<div style="position:absolute; top:2px; right:2px; background:var(--warning); color:#000; font-size:0.6rem; padding:2px 4px; border-radius:4px; font-weight:bold;">🪙${p.price}</div>`;

                        item.innerHTML = `<img src="${p.mainUrl}" style="padding:0; object-fit:cover; border-radius:8px;">${badge}${priceBadge}`;
                        item.onclick = () => {
                            if(p.status !== 'approved' && p.ownerUid !== currentUser.username) return;
                            if(needBuy) app.promptPurchasePack(p); else app.loadStamps(p.id);
                        };
                        list.appendChild(item);
                    });
                }
            },
            promptPurchasePack: async (p) => {
                if(!confirm(`「${p.title}」を ${p.price} コインで購入しますか？\n(作成者に70%が還元されます)`)) return;
                if((currentUser.coins||0) < p.price) return app.toast("コインが足りません");
                try {
                    await runTransaction(db, async tr => {
                        const meRef = doc(db, "users", currentUser.username);
                        const sellerRef = doc(db, "users", p.ownerUid);
                        const sysRef = doc(db, "system", "stats");
                        
                        const meSnap = await tr.get(meRef);
                        if((meSnap.data().coins||0) < p.price) throw "コイン不足";
                        
                        const devFee = Math.floor(p.price * 0.3);
                        const sellerProfit = p.price - devFee;
                        
                        tr.update(meRef, { coins: increment(-p.price), purchasedPacks: arrayUnion(p.id) });
                        tr.update(sellerRef, { coins: increment(sellerProfit) });
                        tr.set(sysRef, { devCoins: increment(devFee) }, {merge:true});
                    });
                    app.toast("購入しました！"); app.loadStamps();
                } catch(e) { app.toast("エラー: " + e); }
            },

            openStampMaker: () => { app.go('scr-stamp-maker'); app.pkLoadDraft(); app.pkRender(); app.loadMyStampsTop(); setTimeout(()=>app.mkInit(), 50); },
            closeStampMaker: () => { app.pkCloseEditor(); app.go('scr-main'); },
            pkSaveDraft: () => {
                app.pkDraft.title = document.getElementById('pk-title').value;
                app.pkDraft.isPublic = document.getElementById('pk-public').value === 'true';
                app.pkDraft.isPaid = document.getElementById('pk-price-type').value === 'paid';
                app.pkDraft.price = parseInt(document.getElementById('pk-price-val').value||'0');
                localStorage.setItem(PK_DRAFT_KEY, JSON.stringify(app.pkDraft)); app.toast('保存しました');
            },
            pkLoadDraft: () => {
                try { const r = localStorage.getItem(PK_DRAFT_KEY); if(r) { const d=JSON.parse(r); app.pkDraft={id:d.id||null, title:d.title||'', isPublic:!!d.isPublic, isPaid:!!d.isPaid, price:d.price||0, mainDataUrl:d.mainDataUrl||'', stamps:Array.isArray(d.stamps)?d.stamps:[]}; } } catch(e) {}
                document.getElementById('pk-title').value = app.pkDraft.title;
                document.getElementById('pk-public').value = app.pkDraft.isPublic?'true':'false';
                document.getElementById('pk-price-type').value = app.pkDraft.isPaid?'paid':'free';
                document.getElementById('pk-price-val').value = app.pkDraft.price || '';
                const mp = document.getElementById('pk-main-preview');
                if(app.pkDraft.mainDataUrl){ mp.src=app.pkDraft.mainDataUrl; mp.style.display='block'; } else mp.style.display='none';
                document.getElementById('pk-price-type').dispatchEvent(new Event('change'));
            },
            pkResetDraft: () => { if(confirm('リセットしますか？')){ localStorage.removeItem(PK_DRAFT_KEY); app.pkDraft={id:null, title:'',isPublic:true,isPaid:false,price:0,mainDataUrl:'',stamps:[]}; app.pkLoadDraft(); app.pkRender(); app.pkGoToStep1(); } },
            pkGoToStep1: () => { document.getElementById('pk-step-basic').style.display='block'; document.getElementById('pk-step-stamps').style.display='none'; },
            pkGoToStep2: () => { app.pkRender(); document.getElementById('pk-step-basic').style.display='none'; document.getElementById('pk-step-stamps').style.display='block'; },
            pkAddEmptySlot: (c=1) => { const add=Math.min(c, 40-app.pkDraft.stamps.length); for(let i=0;i<add;i++) app.pkDraft.stamps.push({dataUrl:''}); app.pkRender(); },
            pkRender: () => {
                app.pkDraft.title = document.getElementById('pk-title').value.trim();
                const grid = document.getElementById('pk-grid'); if(!grid) return;
                while(app.pkDraft.stamps.length < 8) app.pkDraft.stamps.push({dataUrl:''});
                grid.innerHTML = '';
                app.pkDraft.stamps.forEach((s, i) => {
                    grid.innerHTML += `<div class="pk-slot">
                        <div class="pk-thumb">${s.dataUrl?`<img src="${s.dataUrl}">`:`<div class='text-xs text-sub'>未設定</div>`}</div>
                        <div class="mt-2 flex gap-2"><button class="btn btn-ghost btn-sm" onclick="app.pkUploadToSlot(${i})">${s.dataUrl?'変更':'追加'}</button><button class="btn btn-primary btn-sm" onclick="app.pkOpenEditor('slot', ${i})">編集</button><button class="btn btn-danger btn-sm" onclick="app.pkRemoveSlot(${i})">✕</button></div>
                    </div>`;
                });
                app.pkValidate();
            },
            pkRemoveSlot: (i) => { app.pkDraft.stamps.splice(i,1); app.pkRender(); },
            pkHandleMainFile: async (i) => { if(i.files[0]){ const u=await app.pkNormalizeImg(i.files[0]); if(u){ app.pkDraft.mainDataUrl=u; document.getElementById('pk-main-preview').src=u; document.getElementById('pk-main-preview').style.display='block'; app.pkRender(); } i.value=''; } },
            pkHandleBulkFiles: async (i) => { if(i.files.length){ for(const f of i.files){ const u=await app.pkNormalizeImg(f); if(u) app.pkDraft.stamps.push({dataUrl:u}); } i.value=''; app.pkRender(); } },
            pkUploadToSlot: (i) => { const p=document.createElement('input'); p.type='file'; p.accept='image/*'; p.onchange=async()=>{ if(p.files[0]){ const u=await app.pkNormalizeImg(p.files[0]); if(u) app.pkDraft.stamps[i].dataUrl=u; app.pkRender(); } }; p.click(); },
            pkNormalizeImg: async (file) => {
                if(file.size > 2*1024*1024) { app.toast('大きすぎます(2MBまで)'); return null; }
                const url = URL.createObjectURL(file); const img = new Image();
                await new Promise(r => { img.onload=r; img.src=url; });
                const c = document.createElement('canvas'); c.width=150; c.height=150; const ctx=c.getContext('2d');
                const scale = Math.min(150/img.width, 150/img.height); const w=img.width*scale, h=img.height*scale;
                ctx.drawImage(img, (150-w)/2, (150-h)/2, w, h);
                return c.toDataURL('image/webp', 0.9);
            },
            pkValidate: () => {
                const title = document.getElementById('pk-title')?.value.trim();
                const isPaid = document.getElementById('pk-price-type')?.value === 'paid';
                const price = parseInt(document.getElementById('pk-price-val')?.value || '0');
                const hasMain = !!app.pkDraft.mainDataUrl;
                let okTitle = title.length>=1 && title.length<=24;
                let okPrice = isPaid ? (price >= 100 && price <= 10000) : true;
                
                const bNext = document.getElementById('pk-btn-next');
                if(bNext) {
                    if(okTitle && okPrice && hasMain) { bNext.disabled=false; bNext.className='btn btn-primary'; }
                    else { bNext.disabled=true; bNext.className='btn btn-ghost'; }
                }
                const vBox = document.getElementById('pk-validate'); if(!vBox) return;
                const stamps = app.pkDraft.stamps.filter(s=>!!s.dataUrl);
                if(stamps.length < 8) { vBox.innerText = `スタンプ不足 (${stamps.length}/8)`; vBox.className='mk-pill mk-warn'; }
                else { vBox.innerText = 'OK (申請可能)'; vBox.className='mk-pill'; }
            },
            pkSubmitPack: async () => {
                const t=app.pkDraft.title, pub=document.getElementById('pk-public').value==='true';
                const isPaid = document.getElementById('pk-price-type').value === 'paid', price = parseInt(document.getElementById('pk-price-val').value||'0');
                const sts = app.pkDraft.stamps.filter(s=>!!s.dataUrl);
                if(sts.length<8) return app.toast('8個以上必要です');
                if(isPaid && (price<100 || price>10000)) return app.toast('価格が不正です');
                if(!confirm(app.pkDraft.id ? `このパックを更新して再申請しますか？\n(ステータスは審査待ちに戻ります)` : `申請しますか？`)) return;
                try {
                    const packId = app.pkDraft.id || doc(collection(db,'stampPacks')).id;
                    const packRef = doc(db, 'stampPacks', packId);
                    
                    if(app.pkDraft.id) {
                        const oldStamps = await getDocs(query(collection(db, 'stamps'), where('packId', '==', packId)));
                        const batch = writeBatch(db);
                        oldStamps.forEach(d => batch.delete(d.ref));
                        await batch.commit();
                    }

                    await setDoc(packRef, { title:t, mainUrl:app.pkDraft.mainDataUrl, ownerUid:currentUser.username, isPublic:pub, isPaid, price, status:'pending', createdAt:serverTimestamp(), count:sts.length });
                    const batch = writeBatch(db);
                    for(let i=0;i<sts.length;i++) {
                        const sRef = doc(collection(db,'stamps'));
                        batch.set(sRef, { url:sts[i].dataUrl, ownerUid:currentUser.username, status:'pending', packId:packId, order:i });
                    }
                    await batch.commit();

                    app.toast(app.pkDraft.id ? '更新して再申請しました' : '申請しました'); 
                    localStorage.removeItem(PK_DRAFT_KEY); app.pkGoToStep1(); app.closeStampMaker();
                } catch(e) { console.error(e); app.toast('エラー'); }
            },
            
            loadMyStampsTop: async () => {
                const list = document.getElementById('stamps-top-list'); if(!list) return; list.innerHTML = "";
                const snap = await getDocs(query(collection(db, 'stampPacks'), where('ownerUid','==', currentUser.username), limit(20)));
                let html=''; const rows=[]; snap.forEach(d=>rows.push({id:d.id, ...d.data()})); rows.sort((a,b)=>(b.createdAt?.seconds||0)-(a.createdAt?.seconds||0));
                for(const p of rows) {
                    const st = p.status || 'pending';
                    html += `<div class="flex items-center gap-3 border-b border-[var(--border)] p-2">
                        <img src="${p.mainUrl}" style="width:44px;height:44px;border-radius:8px">
                        <div class="flex-1"><div class="font-bold">${p.title}</div><div class="text-xs text-sub">${p.count}個 / ${p.isPaid?`有料(${p.price})`:'無料'} / ${st==='approved'?'承認':(st==='rejected'?'却下':'申請中')}</div></div>
                        <button class="btn btn-ghost btn-sm" onclick="app.editPack('${p.id}')">編集</button>
                    </div>`;
                }
                list.innerHTML = html;
            },
            editPack: async (packId) => {
                if(!confirm('承認済みのパックを編集すると、再び審査待ちになります。よろしいですか？')) return;
                try {
                    const packSnap = await getDoc(doc(db, 'stampPacks', packId));
                    if(!packSnap.exists()) return;
                    const p = packSnap.data();
                    const stampsSnap = await getDocs(query(collection(db, 'stamps'), where('packId', '==', packId)));
                    const stamps = [];
                    stampsSnap.forEach(d => stamps.push(d.data()));
                    stamps.sort((a,b)=>(a.order||0)-(b.order||0));
                    
                    app.pkDraft = { id: packId, title: p.title, isPublic: p.isPublic, isPaid: !!p.isPaid, price: p.price || 0, mainDataUrl: p.mainUrl, stamps: stamps.map(s => ({ dataUrl: s.url })) };
                    localStorage.setItem(PK_DRAFT_KEY, JSON.stringify(app.pkDraft));
                    app.openStampMaker(); 
                } catch(e) { app.toast('読み込みエラー'); }
            },

            // Stamp Editor Canvas
            mkState: { tool: 'move', color: '#ffffff', stroke: 8, eraser: false, bg: 'transparent', history: [], dragging: false, last: null, imgObj: null, imgTransform: { x: 0, y: 0, s: 1 }, tempShape: null },
            mkCanvas: null, mkCtx: null,
            pkEditing: { kind: null, index: null },
            pkOpenEditor: (kind, index=null) => {
                app.pkEditing = { kind, index }; document.getElementById('mk-editor-card').style.display = 'block';
                document.getElementById('mk-edit-target').innerText = kind === 'main' ? 'メイン画像' : `スタンプ #${(index||0)+1}`;
                app.mkState.history = []; app.mkState.imgObj = null; app.mkState.imgTransform = { x:0, y:0, s:1 };
                try { app.mkCtx?.clearRect(0,0,app.mkCanvas.width, app.mkCanvas.height); } catch(e) {}
                app.mkPushHistory();
                const u = (kind==='main') ? app.pkDraft.mainDataUrl : (app.pkDraft.stamps[index]?.dataUrl||'');
                if(u) {
                    const img = new Image(); img.onload = () => { app.mkState.imgObj = img; app.mkState.imgTransform = { x:0, y:0, s: Math.min(1, 512/Math.max(img.width, img.height)) }; app.mkRedrawAll(); }; img.src = u;
                }
                setTimeout(()=>document.getElementById('mk-editor-card').scrollIntoView({behavior:'smooth'}), 50);
            },
            pkCloseEditor: () => { document.getElementById('mk-editor-card').style.display = 'none'; },
            mkInit: () => {
                const c = document.getElementById('mk-canvas'); if(!c) return; app.mkCanvas = c; app.mkCtx = c.getContext('2d'); app.mkPushHistory();
                const getPos = (ev) => { const r = c.getBoundingClientRect(), x = (('touches' in ev) ? ev.touches[0].clientX : ev.clientX) - r.left, y = (('touches' in ev) ? ev.touches[0].clientY : ev.clientY) - r.top; return { x: x * (c.width/r.width), y: y * (c.height/r.height) }; };
                const onDown = (ev) => {
                    ev.preventDefault(); const p = getPos(ev); app.mkState.dragging = true; app.mkState.last = p;
                    if(app.mkState.tool === 'text') { const txt = prompt('文字を入力'); if(txt) { app.mkDrawText(txt, p.x, p.y); app.mkState.dragging = false; } return; }
                    if(app.mkState.tool === 'rect') { app.mkState.tempShape = { x0:p.x, y0:p.y, x1:p.x, y1:p.y }; return; }
                    if(app.mkState.tool === 'move') return;
                    app.mkCtx.lineCap = 'round'; app.mkCtx.lineJoin = 'round'; app.mkCtx.beginPath(); app.mkCtx.moveTo(p.x, p.y);
                };
                const onMove = (ev) => {
                    if(!app.mkState.dragging) return; ev.preventDefault(); const p = getPos(ev), last = app.mkState.last; if(!last) { app.mkState.last = p; return; }
                    if(app.mkState.tool === 'move') { app.mkState.imgTransform.x += (p.x-last.x); app.mkState.imgTransform.y += (p.y-last.y); app.mkRedrawAll(); app.mkState.last = p; return; }
                    if(app.mkState.tool === 'rect') { app.mkState.tempShape.x1 = p.x; app.mkState.tempShape.y1 = p.y; app.mkRedrawAll(true); app.mkState.last = p; return; }
                    app.mkCtx.strokeStyle = app.mkState.eraser ? 'rgba(0,0,0,1)' : app.mkState.color; app.mkCtx.globalCompositeOperation = app.mkState.eraser ? 'destination-out' : 'source-over'; app.mkCtx.lineWidth = app.mkState.stroke; app.mkCtx.lineTo(p.x, p.y); app.mkCtx.stroke(); app.mkState.last = p;
                };
                const onUp = (ev) => {
                    if(!app.mkState.dragging) return; ev.preventDefault(); app.mkState.dragging = false;
                    if(app.mkState.tool === 'rect' && app.mkState.tempShape) { app.mkCommitRect(app.mkState.tempShape); app.mkState.tempShape = null; }
                    app.mkCtx.globalCompositeOperation = 'source-over'; app.mkPushHistory();
                };
                c.addEventListener('mousedown', onDown); window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp);
                c.addEventListener('touchstart', onDown, {passive:false}); c.addEventListener('touchmove', onMove, {passive:false}); c.addEventListener('touchend', onUp, {passive:false});
            },
            mkPushHistory: () => { try { if(!app.mkCanvas) return; const url = app.mkCanvas.toDataURL('image/png'); app.mkState.history.push(url); if(app.mkState.history.length > 30) app.mkState.history.shift(); } catch(e) {} },
            mkUndo: () => { if(app.mkState.history.length <= 1) return; app.mkState.history.pop(); const url = app.mkState.history[app.mkState.history.length-1]; const img = new Image(); img.onload = () => { app.mkCtx.clearRect(0,0,app.mkCanvas.width, app.mkCanvas.height); app.mkCtx.drawImage(img, 0,0); }; img.src = url; },
            mkClear: () => { if(!confirm('クリアしますか？')) return; app.mkCtx.clearRect(0,0,app.mkCanvas.width, app.mkCanvas.height); app.mkState.imgObj = null; app.mkState.imgTransform = { x:0, y:0, s:1 }; app.mkState.tempShape = null; app.mkPushHistory(); },
            mkSetTool: (t) => { app.mkState.tool = t; ['move','pen','rect','text'].forEach(x => { const el=document.getElementById('tool-'+x); if(el) el.classList.toggle('active', x===t); }); },
            mkUpdateStyle: () => { app.mkState.stroke = parseInt(document.getElementById('mk-stroke').value||'8'); document.getElementById('mk-stroke-v').innerText=app.mkState.stroke; app.mkState.color = document.getElementById('mk-color').value; },
            mkToggleEraser: () => { app.mkState.eraser = !app.mkState.eraser; document.getElementById('mk-eraser').classList.toggle('active', app.mkState.eraser); },
            mkSetBgTransparent: () => { app.mkState.bg = 'transparent'; },
            mkSetBgWhite: () => { app.mkState.bg = 'white'; const tmp = document.createElement('canvas'); tmp.width = app.mkCanvas.width; tmp.height = app.mkCanvas.height; const tctx = tmp.getContext('2d'); tctx.fillStyle = '#fff'; tctx.fillRect(0,0,tmp.width,tmp.height); tctx.drawImage(app.mkCanvas,0,0); app.mkCtx.clearRect(0,0,app.mkCanvas.width, app.mkCanvas.height); app.mkCtx.drawImage(tmp,0,0); app.mkPushHistory(); },
            mkRedrawAll: (pre=false) => {
                const baseImg = new Image(); baseImg.onload = () => {
                    app.mkCtx.clearRect(0,0,app.mkCanvas.width, app.mkCanvas.height); app.mkCtx.drawImage(baseImg,0,0);
                    if(app.mkState.imgObj) { const im = app.mkState.imgObj, tr = app.mkState.imgTransform, w = im.width * tr.s, h = im.height * tr.s; app.mkCtx.drawImage(im, (app.mkCanvas.width-w)/2 + tr.x, (app.mkCanvas.height-h)/2 + tr.y, w, h); }
                    if(pre && app.mkState.tempShape) { const sh = app.mkState.tempShape; app.mkCtx.save(); app.mkCtx.globalCompositeOperation = 'source-over'; app.mkCtx.strokeStyle = app.mkState.color; app.mkCtx.lineWidth = app.mkState.stroke; app.mkCtx.strokeRect(sh.x0, sh.y0, sh.x1-sh.x0, sh.y1-sh.y0); app.mkCtx.restore(); }
                }; baseImg.src = app.mkState.history[app.mkState.history.length-1];
            },
            mkCommitRect: (sh) => { app.mkCtx.save(); app.mkCtx.globalCompositeOperation = app.mkState.eraser ? 'destination-out' : 'source-over'; app.mkCtx.strokeStyle = app.mkState.color; app.mkCtx.lineWidth = app.mkState.stroke; app.mkCtx.strokeRect(sh.x0, sh.y0, sh.x1-sh.x0, sh.y1-sh.y0); app.mkCtx.restore(); app.mkPushHistory(); },
            mkDrawText: (txt, x, y) => { app.mkCtx.save(); app.mkCtx.globalCompositeOperation = 'source-over'; app.mkCtx.fillStyle = app.mkState.color; app.mkCtx.font = 'bold 72px Inter, sans-serif'; app.mkCtx.textBaseline = 'middle'; app.mkCtx.fillText(txt, x, y); app.mkCtx.restore(); app.mkPushHistory(); },
            mkExportWebP: async () => { const out = document.createElement('canvas'); out.width = 150; out.height = 150; const octx = out.getContext('2d'); if(app.mkState.bg === 'white') { octx.fillStyle = '#fff'; octx.fillRect(0,0,150,150); } octx.drawImage(app.mkCanvas, 0, 0, 150, 150); return out.toDataURL('image/webp', 0.9); },
            pkSaveEditedStamp: async () => {
                const u = await app.mkExportWebP();
                if(app.pkEditing.kind === 'main') { app.pkDraft.mainDataUrl = u; document.getElementById('pk-main-preview').src = u; document.getElementById('pk-main-preview').style.display='block'; }
                else if(app.pkEditing.kind === 'slot') { app.pkDraft.stamps[app.pkEditing.index].dataUrl = u; }
                app.pkRender(); app.toast('反映しました'); app.pkCloseEditor();
            },
            pkSetAsMainFromCurrent: async () => {
                const u = await app.mkExportWebP(); app.pkDraft.mainDataUrl = u; document.getElementById('pk-main-preview').src = u; document.getElementById('pk-main-preview').style.display='block'; app.pkRender(); app.toast('メイン画像に設定しました');
            },

            // Trade & Market (Shop)
            switchTradeTab: (mode) => {
                document.getElementById('trade-area-exchange').classList.toggle('hidden', mode!=='exchange');
                document.getElementById('trade-area-market').classList.toggle('hidden', mode!=='market');
                document.getElementById('sw-trade-exchange').classList.toggle('active', mode==='exchange');
                document.getElementById('sw-trade-market').classList.toggle('active', mode==='market');
            },
            tradeRowSeq: 0,
            initTradeUI: () => {
                const g = document.getElementById('tr-give-rows'), w = document.getElementById('tr-want-rows');
                if(g && g.childElementCount===0) app.addTradeRow('give');
                if(w && w.childElementCount===0) app.addTradeRow('want');
            },
            addTradeRow: (side) => {
                const wrap = document.getElementById(side === 'give' ? 'tr-give-rows' : 'tr-want-rows');
                const idx = ++app.tradeRowSeq;
                let opts = `<option value="coins">コイン</option><option value="diamonds">ダイヤ</option><option value="item">消費アイテム(ID)</option><option value="amulet">お守り(ID)</option>`;
                wrap.innerHTML += `<div class="flex gap-2 items-center mb-2" data-idx="${idx}"><select class="input" style="width:40%" id="tr-${side}-type-${idx}">${opts}</select><input type="text" class="input flex-1" id="tr-${side}-val-${idx}" placeholder="量またはID"><button class="btn btn-ghost btn-sm" onclick="this.parentElement.remove()">✕</button></div>`;
            },
            clearTradeRows: (side) => { document.getElementById(side === 'give' ? 'tr-give-rows' : 'tr-want-rows').innerHTML = ''; app.addTradeRow(side); },
            readTradeRows: (side) => {
                const rows = [];
                document.getElementById(side === 'give' ? 'tr-give-rows' : 'tr-want-rows').querySelectorAll('[data-idx]').forEach(el => {
                    const idx = el.dataset.idx, type = document.getElementById(`tr-${side}-type-${idx}`).value, val = document.getElementById(`tr-${side}-val-${idx}`).value;
                    if(val) { if(type==='coins'||type==='diamonds') rows.push({type, amount:parseInt(val)}); else rows.push({type, id:val, qty:1}); }
                });
                return rows;
            },
            createTrade: async () => {
                const give = app.readTradeRows('give'), want = app.readTradeRows('want'), pass = document.getElementById('tr-pass').value.trim();
                if(give.length===0 || want.length===0) return app.toast('内容を入力してください');
                try {
                    await addDoc(collection(db, 'trades'), { makerUid: currentUser.username, makerName: currentUser.name, give, want, passcode: pass, status: 'open', createdAt: serverTimestamp() });
                    app.toast('出品しました'); app.clearTradeRows('give'); app.clearTradeRows('want'); document.getElementById('tr-pass').value='';
                } catch(e) {}
            },
            cancelTrade: async (id) => { if(confirm('取り消しますか？')) await deleteDoc(doc(db, 'trades', id)); },
            doTrade: async (id, pass) => {
                if(pass && prompt('あいことば')!==pass) return app.toast('違います');
                if(!confirm('交換しますか？(※ロジック簡易版)')) return;
                await deleteDoc(doc(db, 'trades', id)); app.toast('成立！(アイテムは自動増減されません)');
            },
            subTrade: () => {
                listeners.push(onSnapshot(query(collection(db,"trades"), where("status","==","open"), limit(100)), s=>{
                    const l=document.getElementById('trade-list'); l.innerHTML="";
                    let items = []; s.forEach(d => items.push({id:d.id, ...d.data()})); items.sort((a,b) => (b.createdAt?.seconds||0) - (a.createdAt?.seconds||0));
                    items.forEach(t=>{
                        const me=t.makerUid===currentUser.username; const pass = t.passcode ? `'${t.passcode.replace(/'/g,"\\'")}'` : "''";
                        const fmt = (arr) => arr.map(o=>(o.type==='coins'||o.type==='diamonds')?`${o.amount}${o.type}`:`${o.id}x${o.qty}`).join(', ');
                        l.innerHTML += `<div class="card flex justify-between items-center" style="margin-bottom:8px"><div style="flex:1"><div class="text-xs text-sub mb-1">${t.makerName} ${t.passcode?'🔒':''}</div><div class="font-bold">出: ${fmt(t.give)}</div><div class="font-bold text-primary">求: ${fmt(t.want)}</div></div><button class="btn btn-sm ${me?'btn-danger':'btn-primary'}" style="width:auto" onclick="${me?`app.cancelTrade('${t.id}')`:`app.doTrade('${t.id}',${pass})`}">${me?'取消':'交換'}</button></div>`;
                    });
                }));
            },

            // Market
            onMarketTypeChange: () => {
                const type = document.getElementById('mk-sell-type').value;
                const wrap = document.getElementById('mk-sell-valwrap');
                let opts = '';
                if(type === 'item') {
                    for(const [k,v] of Object.entries(currentUser.items||{})) if(v>0) opts += `<option value="${k}">${getMeta('item', k).name} (所持:${v})</option>`;
                } else if(type === 'amulet') {
                    const map = {}; (currentUser.amulets||[]).forEach(a => { const id = typeof a==='string'?a:a.id; map[id]=(map[id]||0)+1; });
                    for(const [id,c] of Object.entries(map)) opts += `<option value="${id}">${getMeta('amulet', id).name} (所持:${c})</option>`;
                }
                if(!opts) opts = `<option value="">出品できるものがありません</option>`;
                wrap.innerHTML = `<div class="flex gap-2"><select id="mk-sell-val" class="input flex-1">${opts}</select><input type="number" id="mk-sell-qty" class="input" style="width:70px" min="1" value="1"></div>`;
            },
            createMarketItem: async () => {
                const type = document.getElementById('mk-sell-type').value, val = document.getElementById('mk-sell-val').value, qty = parseInt(document.getElementById('mk-sell-qty').value || '1'), price = parseInt(document.getElementById('mk-sell-price').value || '0');
                if(!val || qty<1 || price<10) return app.toast('正しく入力してください（価格は10コイン以上）');
                try {
                    await runTransaction(db, async tr => {
                        const meRef = doc(db, 'users', currentUser.username); const meSnap = await tr.get(meRef); const u = meSnap.data();
                        const items = u.items || {}; const amulets = u.amulets || [];
                        if(type === 'item') { if((items[val]||0) < qty) throw "所持数が足りません"; items[val] -= qty; if(items[val]<=0) delete items[val]; } 
                        else if(type === 'amulet') {
                            const have = amulets.filter(a => (typeof a==='string'?a:a.id) === val);
                            if(have.length < qty) throw "所持数が足りません";
                            for(let i=0; i<qty; i++) { const idx = amulets.findIndex(a => (typeof a==='string'?a:a.id) === val); amulets.splice(idx, 1); }
                        }
                        tr.update(meRef, { items, amulets });
                        tr.set(doc(collection(db, 'market')), { sellerUid: currentUser.username, sellerName: currentUser.name, type, itemId: val, qty, price, status: 'open', createdAt: serverTimestamp() });
                    });
                    app.toast('出品しました'); document.getElementById('mk-sell-price').value=''; app.onMarketTypeChange();
                } catch(e) { app.toast('エラー: ' + e); }
            },
            buyMarketItem: async (mId) => {
                if(!confirm("このアイテムをコインで購入しますか？")) return;
                try {
                    await runTransaction(db, async tr => {
                        const mRef = doc(db, 'market', mId); const mSnap = await tr.get(mRef);
                        if(!mSnap.exists() || mSnap.data().status !== 'open') throw "売却済みか存在しません";
                        const m = mSnap.data(); if(m.sellerUid === currentUser.username) throw "自分の出品です";
                        const meRef = doc(db, 'users', currentUser.username), sellerRef = doc(db, 'users', m.sellerUid);
                        const meSnap = await tr.get(meRef); const u = meSnap.data();
                        if((u.coins||0) < m.price) throw "コイン不足";
                        const items = u.items || {}; const amulets = u.amulets || [];
                        if(m.type === 'item') items[m.itemId] = (items[m.itemId]||0) + m.qty;
                        else if(m.type === 'amulet') { for(let i=0; i<m.qty; i++) amulets.push({ id: m.itemId, durability: getMeta('amulet', m.itemId).durability || 100 }); }
                        tr.update(meRef, { coins: increment(-m.price), items, amulets }); tr.update(sellerRef, { coins: increment(m.price) }); tr.delete(mRef);
                    });
                    app.toast("購入しました！");
                } catch(e) { app.toast("エラー: " + e); }
            },
            cancelMarketItem: async (mId) => {
                if(!confirm("出品を取り消しますか？")) return;
                try {
                    await runTransaction(db, async tr => {
                        const mRef = doc(db, 'market', mId); const mSnap = await tr.get(mRef);
                        if(!mSnap.exists()) throw "存在しません"; const m = mSnap.data(); if(m.sellerUid !== currentUser.username) throw "権限がありません";
                        const meRef = doc(db, 'users', currentUser.username); const meSnap = await tr.get(meRef);
                        const items = meSnap.data().items || {}; const amulets = meSnap.data().amulets || [];
                        if(m.type === 'item') items[m.itemId] = (items[m.itemId]||0) + m.qty;
                        else if(m.type === 'amulet') { for(let i=0; i<m.qty; i++) amulets.push({ id: m.itemId, durability: 100 }); }
                        tr.update(meRef, { items, amulets }); tr.delete(mRef);
                    });
                    app.toast("取り消しました"); app.onMarketTypeChange();
                } catch(e) { app.toast("エラー"); }
            },
            subMarket: () => {
                listeners.push(onSnapshot(query(collection(db, "market"), where("status", "==", "open"), limit(100)), s => {
                    const l = document.getElementById('market-list'); if(!l) return; l.innerHTML = "";
                    let items = []; s.forEach(d => items.push({ id: d.id, ...d.data() })); items.sort((a,b) => (b.createdAt?.seconds||0) - (a.createdAt?.seconds||0));
                    items.forEach(m => {
                        const isMe = m.sellerUid === currentUser.username; const meta = getMeta(m.type, m.itemId);
                        l.innerHTML += `<div class="card flex justify-between items-center" style="margin-bottom:8px"><div style="flex:1; padding-right:10px"><div class="text-xs text-sub mb-1">出品者: ${m.sellerName}</div><div class="font-bold">${meta.icon} ${meta.name} ×${m.qty}</div><div class="font-bold mt-1" style="color:var(--warning)">🪙 ${m.price} コイン</div></div><button class="btn btn-sm ${isMe ? 'btn-ghost' : 'btn-primary'}" style="width:auto" onclick="${isMe ? `app.cancelMarketItem('${m.id}')` : `app.buyMarketItem('${m.id}')`}">${isMe ? '取消' : '購入'}</button></div>`;
                    });
                }));
            },

            // Admin Logic
            checkAdmSess: () => { 
                const e=localStorage.getItem(ADM_KEY); 
                if(e&&parseInt(e)>Date.now()){ document.getElementById('nav-adm-pc').classList.remove('hidden'); return true; }
                document.getElementById('nav-adm-pc').classList.add('hidden'); return false; 
            },
            authAdmin: async () => {
                const c=document.getElementById('adm-code').value; 
                let vc="cotobato-admin"; try { const d=await getDoc(doc(db,"system","config")); if(d.exists() && d.data().code) vc=d.data().code; } catch(e) {}
                if(c===vc){ localStorage.setItem(ADM_KEY, Date.now()+1800000); document.getElementById('nav-adm-pc').classList.remove('hidden'); app.tab('admin'); app.toast("認証成功"); document.getElementById('adm-code').value=""; } else app.toast("違います");
            },
            applyPenalty: async (type) => {
                if(!app.checkAdmSess()) return;
                const uid = document.getElementById('adm-police-uid').value.trim();
                if(!uid) return app.toast('IDを入力してください');
                if(!confirm(`ユーザー ${uid} に ${type} を実行しますか？`)) return;
                try {
                    const ref = doc(db, "users", uid);
                    const changes = { lastPenaltyAt: serverTimestamp() };
                    if(type === 'mute') changes.isMuted = true;
                    if(type === 'ban') changes.isBanned = true;
                    if(type === 'wipe') { changes.coins = 0; changes.diamonds = 0; }
                    await updateDoc(ref, changes);
                    app.toast(`実行しました: ${type}`);
                } catch(e) { app.toast('エラー: ユーザー不在など'); }
            },
            subAdmList: () => {
                onSnapshot(query(collection(db,"announcements"), limit(50)), s=>{
                    const l=document.getElementById('adm-list-news'); l.innerHTML="";
                    s.forEach(d=>{ const n=d.data(); l.innerHTML+=`<div class="card p-2 mb-2 flex justify-between"><div>${n.title}</div><button class="btn btn-sm btn-danger" onclick="app.delDoc('announcements','${d.id}')">削除</button></div>`; });
                });
                onSnapshot(query(collection(db,"gifts"), limit(30)), s=>{
                    const l=document.getElementById('adm-list-gifts'); l.innerHTML="";
                    s.forEach(d=>{ const g=d.data(); l.innerHTML+=`<div class="card p-2 mb-2 flex justify-between"><div>${g.val} ${g.type}</div><button class="btn btn-sm btn-danger" onclick="app.delDoc('gifts','${d.id}')">削除</button></div>`; });
                });
            },
            postNews: async () => {
                const ti=document.getElementById('adm-news-title').value, bo=document.getElementById('adm-news-body').value, pi=document.getElementById('adm-news-pin').checked, da=document.getElementById('adm-news-date').value;
                if(!ti) return;
                const d={title:ti, body:bo, pin:pi}; if(newsImg) d.img=newsImg; if(da) d.publishAt=Timestamp.fromDate(new Date(da)); else d.publishAt=serverTimestamp();
                await addDoc(collection(db,"announcements"), d); app.toast("配信しました"); document.getElementById('adm-news-title').value=""; document.getElementById('adm-news-body').value="";
            },
            distributeGift: async () => {
                const ty=document.getElementById('adm-gift-type').value, va=parseInt(document.getElementById('adm-gift-val').value), ms=document.getElementById('adm-gift-msg').value;
                if(!va) return;
                await addDoc(collection(db,"gifts"), {type:ty, val:va, msg:ms, to:"all", claimedBy:[], createdAt:serverTimestamp()}); app.toast("配布しました");
            },
            delDoc: async (c,i) => { if(confirm("削除しますか？")) await deleteDoc(doc(db,c,i)); },
            admLoadStampQueue: async () => {
                const box = document.getElementById('adm-stamp-queue'); if(!box) return; box.innerHTML = "";
                const snap = await getDocs(query(collection(db,'stampPacks'), where('status','==','pending'), limit(20)));
                if(snap.empty) return box.innerHTML = "<div class='text-xs text-sub'>申請はありません</div>";
                snap.forEach(d => { const p = d.data(); box.innerHTML += `<div class="card mb-2 flex justify-between items-center"><div class="font-bold">${p.title} (${p.count}個)</div><button class="btn btn-sm btn-primary" onclick="app.admApprovePack('${d.id}')">一括承認</button></div>`; });
            },
            admApprovePack: async (packId) => {
                await updateDoc(doc(db,'stampPacks', packId), { status:'approved' });
                const snap = await getDocs(query(collection(db, 'stamps'), where('packId', '==', packId)));
                snap.forEach(d => updateDoc(doc(db, 'stamps', d.id), { status:'approved' }));
                app.toast('承認しました'); app.admLoadStampQueue();
            },
            admShowApprovedStamps: async () => {
                const snap = await getDocs(query(collection(db,'stampPacks'), where('status','==','approved'), limit(50)));
                let html = '';
                snap.forEach(d => { const p=d.data(); html+=`<div class="flex justify-between items-center border-b border-[var(--border)] py-2"><div>${p.title}</div><button class="btn btn-sm btn-danger" onclick="if(confirm('削除?')) app.delDoc('stampPacks','${d.id}')">削</button></div>`; });
                app.mdl('承認済みパック', html||'なし');
            },

            mdl: (t,c) => { document.getElementById('mdl-title').innerText=t; document.getElementById('mdl-content').innerHTML=c; document.getElementById('modal-base').style.display='flex'; },
            closeModal: () => document.getElementById('modal-base').style.display='none',
            toast: (m) => { const e=document.getElementById('toast'); e.innerText=m; e.classList.add('show'); setTimeout(()=>e.classList.remove('show'),3000); }
        };

        window.addEventListener('load', () => { if(!document.querySelector('.screen.active')) document.getElementById('scr-login').classList.add('active'); });
        window.app = app;
        app.init();
    </script>
</body>
</html>
